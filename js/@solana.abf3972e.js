import{b as gr}from"./base64-js.50a5cdf9.js";import{i as yr}from"./ieee754.44f7831e.js";import{s as wr,u as Me,h as hi,a as gn}from"./@noble.4f8cab65.js";import{B as Vn}from"./bn.js.33a2e93c.js";import{b as Kt}from"./bs58.f06aac8a.js";import{s as fi,d as di,a as pi}from"./borsh.a6c8e978.js";import{t as gi,a as yi}from"./bigint-buffer.f397246a.js";import{c as He,s as T,i as Rn,t as _n,l as St,u as Ve,a as k,n as b,b as q,d as v,o as Y,e as oe,r as mr,f as Wt,g as wi,h as L}from"./superstruct.d6aadb15.js";import{R as mi}from"./jayson.6393c490.js";import{R as bi,c as Bi}from"./rpc-websockets.0194da24.js";var ct={};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(a){const t=gr,n=yr,i=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;a.Buffer=c,a.SlowBuffer=K,a.INSPECT_MAX_BYTES=50;const s=2147483647;a.kMaxLength=s,c.TYPED_ARRAY_SUPPORT=l(),!c.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function l(){try{const o=new Uint8Array(1),e={foo:function(){return 42}};return Object.setPrototypeOf(e,Uint8Array.prototype),Object.setPrototypeOf(o,e),o.foo()===42}catch{return!1}}Object.defineProperty(c.prototype,"parent",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.buffer}}),Object.defineProperty(c.prototype,"offset",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.byteOffset}});function h(o){if(o>s)throw new RangeError('The value "'+o+'" is invalid for option "size"');const e=new Uint8Array(o);return Object.setPrototypeOf(e,c.prototype),e}function c(o,e,r){if(typeof o=="number"){if(typeof e=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return I(o)}return p(o,e,r)}c.poolSize=8192;function p(o,e,r){if(typeof o=="string")return N(o,e);if(ArrayBuffer.isView(o))return x(o);if(o==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof o);if(bt(o,ArrayBuffer)||o&&bt(o.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(bt(o,SharedArrayBuffer)||o&&bt(o.buffer,SharedArrayBuffer)))return y(o,e,r);if(typeof o=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const u=o.valueOf&&o.valueOf();if(u!=null&&u!==o)return c.from(u,e,r);const f=E(o);if(f)return f;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof o[Symbol.toPrimitive]=="function")return c.from(o[Symbol.toPrimitive]("string"),e,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof o)}c.from=function(o,e,r){return p(o,e,r)},Object.setPrototypeOf(c.prototype,Uint8Array.prototype),Object.setPrototypeOf(c,Uint8Array);function w(o){if(typeof o!="number")throw new TypeError('"size" argument must be of type number');if(o<0)throw new RangeError('The value "'+o+'" is invalid for option "size"')}function m(o,e,r){return w(o),o<=0?h(o):e!==void 0?typeof r=="string"?h(o).fill(e,r):h(o).fill(e):h(o)}c.alloc=function(o,e,r){return m(o,e,r)};function I(o){return w(o),h(o<0?0:A(o)|0)}c.allocUnsafe=function(o){return I(o)},c.allocUnsafeSlow=function(o){return I(o)};function N(o,e){if((typeof e!="string"||e==="")&&(e="utf8"),!c.isEncoding(e))throw new TypeError("Unknown encoding: "+e);const r=G(o,e)|0;let u=h(r);const f=u.write(o,e);return f!==r&&(u=u.slice(0,f)),u}function R(o){const e=o.length<0?0:A(o.length)|0,r=h(e);for(let u=0;u<e;u+=1)r[u]=o[u]&255;return r}function x(o){if(bt(o,Uint8Array)){const e=new Uint8Array(o);return y(e.buffer,e.byteOffset,e.byteLength)}return R(o)}function y(o,e,r){if(e<0||o.byteLength<e)throw new RangeError('"offset" is outside of buffer bounds');if(o.byteLength<e+(r||0))throw new RangeError('"length" is outside of buffer bounds');let u;return e===void 0&&r===void 0?u=new Uint8Array(o):r===void 0?u=new Uint8Array(o,e):u=new Uint8Array(o,e,r),Object.setPrototypeOf(u,c.prototype),u}function E(o){if(c.isBuffer(o)){const e=A(o.length)|0,r=h(e);return r.length===0||o.copy(r,0,0,e),r}if(o.length!==void 0)return typeof o.length!="number"||re(o.length)?h(0):R(o);if(o.type==="Buffer"&&Array.isArray(o.data))return R(o.data)}function A(o){if(o>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return o|0}function K(o){return+o!=o&&(o=0),c.alloc(+o)}c.isBuffer=function(e){return e!=null&&e._isBuffer===!0&&e!==c.prototype},c.compare=function(e,r){if(bt(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),bt(r,Uint8Array)&&(r=c.from(r,r.offset,r.byteLength)),!c.isBuffer(e)||!c.isBuffer(r))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===r)return 0;let u=e.length,f=r.length;for(let d=0,g=Math.min(u,f);d<g;++d)if(e[d]!==r[d]){u=e[d],f=r[d];break}return u<f?-1:f<u?1:0},c.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(e,r){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(e.length===0)return c.alloc(0);let u;if(r===void 0)for(r=0,u=0;u<e.length;++u)r+=e[u].length;const f=c.allocUnsafe(r);let d=0;for(u=0;u<e.length;++u){let g=e[u];if(bt(g,Uint8Array))d+g.length>f.length?(c.isBuffer(g)||(g=c.from(g)),g.copy(f,d)):Uint8Array.prototype.set.call(f,g,d);else if(c.isBuffer(g))g.copy(f,d);else throw new TypeError('"list" argument must be an Array of Buffers');d+=g.length}return f};function G(o,e){if(c.isBuffer(o))return o.length;if(ArrayBuffer.isView(o)||bt(o,ArrayBuffer))return o.byteLength;if(typeof o!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof o);const r=o.length,u=arguments.length>2&&arguments[2]===!0;if(!u&&r===0)return 0;let f=!1;for(;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return ne(o).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return r*2;case"hex":return r>>>1;case"base64":return fe(o).length;default:if(f)return u?-1:ne(o).length;e=(""+e).toLowerCase(),f=!0}}c.byteLength=G;function it(o,e,r){let u=!1;if((e===void 0||e<0)&&(e=0),e>this.length||((r===void 0||r>this.length)&&(r=this.length),r<=0)||(r>>>=0,e>>>=0,r<=e))return"";for(o||(o="utf8");;)switch(o){case"hex":return S(this,e,r);case"utf8":case"utf-8":return $t(this,e,r);case"ascii":return nt(this,e,r);case"latin1":case"binary":return C(this,e,r);case"base64":return Tt(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return D(this,e,r);default:if(u)throw new TypeError("Unknown encoding: "+o);o=(o+"").toLowerCase(),u=!0}}c.prototype._isBuffer=!0;function P(o,e,r){const u=o[e];o[e]=o[r],o[r]=u}c.prototype.swap16=function(){const e=this.length;if(e%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let r=0;r<e;r+=2)P(this,r,r+1);return this},c.prototype.swap32=function(){const e=this.length;if(e%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let r=0;r<e;r+=4)P(this,r,r+3),P(this,r+1,r+2);return this},c.prototype.swap64=function(){const e=this.length;if(e%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let r=0;r<e;r+=8)P(this,r,r+7),P(this,r+1,r+6),P(this,r+2,r+5),P(this,r+3,r+4);return this},c.prototype.toString=function(){const e=this.length;return e===0?"":arguments.length===0?$t(this,0,e):it.apply(this,arguments)},c.prototype.toLocaleString=c.prototype.toString,c.prototype.equals=function(e){if(!c.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e?!0:c.compare(this,e)===0},c.prototype.inspect=function(){let e="";const r=a.INSPECT_MAX_BYTES;return e=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(e+=" ... "),"<Buffer "+e+">"},i&&(c.prototype[i]=c.prototype.inspect),c.prototype.compare=function(e,r,u,f,d){if(bt(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),!c.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(r===void 0&&(r=0),u===void 0&&(u=e?e.length:0),f===void 0&&(f=0),d===void 0&&(d=this.length),r<0||u>e.length||f<0||d>this.length)throw new RangeError("out of range index");if(f>=d&&r>=u)return 0;if(f>=d)return-1;if(r>=u)return 1;if(r>>>=0,u>>>=0,f>>>=0,d>>>=0,this===e)return 0;let g=d-f,F=u-r;const J=Math.min(g,F),Z=this.slice(f,d),Q=e.slice(r,u);for(let H=0;H<J;++H)if(Z[H]!==Q[H]){g=Z[H],F=Q[H];break}return g<F?-1:F<g?1:0};function z(o,e,r,u,f){if(o.length===0)return-1;if(typeof r=="string"?(u=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,re(r)&&(r=f?0:o.length-1),r<0&&(r=o.length+r),r>=o.length){if(f)return-1;r=o.length-1}else if(r<0)if(f)r=0;else return-1;if(typeof e=="string"&&(e=c.from(e,u)),c.isBuffer(e))return e.length===0?-1:j(o,e,r,u,f);if(typeof e=="number")return e=e&255,typeof Uint8Array.prototype.indexOf=="function"?f?Uint8Array.prototype.indexOf.call(o,e,r):Uint8Array.prototype.lastIndexOf.call(o,e,r):j(o,[e],r,u,f);throw new TypeError("val must be string, number or Buffer")}function j(o,e,r,u,f){let d=1,g=o.length,F=e.length;if(u!==void 0&&(u=String(u).toLowerCase(),u==="ucs2"||u==="ucs-2"||u==="utf16le"||u==="utf-16le")){if(o.length<2||e.length<2)return-1;d=2,g/=2,F/=2,r/=2}function J(Q,H){return d===1?Q[H]:Q.readUInt16BE(H*d)}let Z;if(f){let Q=-1;for(Z=r;Z<g;Z++)if(J(o,Z)===J(e,Q===-1?0:Z-Q)){if(Q===-1&&(Q=Z),Z-Q+1===F)return Q*d}else Q!==-1&&(Z-=Z-Q),Q=-1}else for(r+F>g&&(r=g-F),Z=r;Z>=0;Z--){let Q=!0;for(let H=0;H<F;H++)if(J(o,Z+H)!==J(e,H)){Q=!1;break}if(Q)return Z}return-1}c.prototype.includes=function(e,r,u){return this.indexOf(e,r,u)!==-1},c.prototype.indexOf=function(e,r,u){return z(this,e,r,u,!0)},c.prototype.lastIndexOf=function(e,r,u){return z(this,e,r,u,!1)};function tt(o,e,r,u){r=Number(r)||0;const f=o.length-r;u?(u=Number(u),u>f&&(u=f)):u=f;const d=e.length;u>d/2&&(u=d/2);let g;for(g=0;g<u;++g){const F=parseInt(e.substr(g*2,2),16);if(re(F))return g;o[r+g]=F}return g}function Pt(o,e,r,u){return Qt(ne(e,o.length-r),o,r,u)}function gt(o,e,r,u){return Qt(qe(e),o,r,u)}function at(o,e,r,u){return Qt(fe(e),o,r,u)}function Ot(o,e,r,u){return Qt(De(e,o.length-r),o,r,u)}c.prototype.write=function(e,r,u,f){if(r===void 0)f="utf8",u=this.length,r=0;else if(u===void 0&&typeof r=="string")f=r,u=this.length,r=0;else if(isFinite(r))r=r>>>0,isFinite(u)?(u=u>>>0,f===void 0&&(f="utf8")):(f=u,u=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const d=this.length-r;if((u===void 0||u>d)&&(u=d),e.length>0&&(u<0||r<0)||r>this.length)throw new RangeError("Attempt to write outside buffer bounds");f||(f="utf8");let g=!1;for(;;)switch(f){case"hex":return tt(this,e,r,u);case"utf8":case"utf-8":return Pt(this,e,r,u);case"ascii":case"latin1":case"binary":return gt(this,e,r,u);case"base64":return at(this,e,r,u);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Ot(this,e,r,u);default:if(g)throw new TypeError("Unknown encoding: "+f);f=(""+f).toLowerCase(),g=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function Tt(o,e,r){return e===0&&r===o.length?t.fromByteArray(o):t.fromByteArray(o.slice(e,r))}function $t(o,e,r){r=Math.min(o.length,r);const u=[];let f=e;for(;f<r;){const d=o[f];let g=null,F=d>239?4:d>223?3:d>191?2:1;if(f+F<=r){let J,Z,Q,H;switch(F){case 1:d<128&&(g=d);break;case 2:J=o[f+1],(J&192)===128&&(H=(d&31)<<6|J&63,H>127&&(g=H));break;case 3:J=o[f+1],Z=o[f+2],(J&192)===128&&(Z&192)===128&&(H=(d&15)<<12|(J&63)<<6|Z&63,H>2047&&(H<55296||H>57343)&&(g=H));break;case 4:J=o[f+1],Z=o[f+2],Q=o[f+3],(J&192)===128&&(Z&192)===128&&(Q&192)===128&&(H=(d&15)<<18|(J&63)<<12|(Z&63)<<6|Q&63,H>65535&&H<1114112&&(g=H))}}g===null?(g=65533,F=1):g>65535&&(g-=65536,u.push(g>>>10&1023|55296),g=56320|g&1023),u.push(g),f+=F}return $(u)}const U=4096;function $(o){const e=o.length;if(e<=U)return String.fromCharCode.apply(String,o);let r="",u=0;for(;u<e;)r+=String.fromCharCode.apply(String,o.slice(u,u+=U));return r}function nt(o,e,r){let u="";r=Math.min(o.length,r);for(let f=e;f<r;++f)u+=String.fromCharCode(o[f]&127);return u}function C(o,e,r){let u="";r=Math.min(o.length,r);for(let f=e;f<r;++f)u+=String.fromCharCode(o[f]);return u}function S(o,e,r){const u=o.length;(!e||e<0)&&(e=0),(!r||r<0||r>u)&&(r=u);let f="";for(let d=e;d<r;++d)f+=de[o[d]];return f}function D(o,e,r){const u=o.slice(e,r);let f="";for(let d=0;d<u.length-1;d+=2)f+=String.fromCharCode(u[d]+u[d+1]*256);return f}c.prototype.slice=function(e,r){const u=this.length;e=~~e,r=r===void 0?u:~~r,e<0?(e+=u,e<0&&(e=0)):e>u&&(e=u),r<0?(r+=u,r<0&&(r=0)):r>u&&(r=u),r<e&&(r=e);const f=this.subarray(e,r);return Object.setPrototypeOf(f,c.prototype),f};function _(o,e,r){if(o%1!==0||o<0)throw new RangeError("offset is not uint");if(o+e>r)throw new RangeError("Trying to access beyond buffer length")}c.prototype.readUintLE=c.prototype.readUIntLE=function(e,r,u){e=e>>>0,r=r>>>0,u||_(e,r,this.length);let f=this[e],d=1,g=0;for(;++g<r&&(d*=256);)f+=this[e+g]*d;return f},c.prototype.readUintBE=c.prototype.readUIntBE=function(e,r,u){e=e>>>0,r=r>>>0,u||_(e,r,this.length);let f=this[e+--r],d=1;for(;r>0&&(d*=256);)f+=this[e+--r]*d;return f},c.prototype.readUint8=c.prototype.readUInt8=function(e,r){return e=e>>>0,r||_(e,1,this.length),this[e]},c.prototype.readUint16LE=c.prototype.readUInt16LE=function(e,r){return e=e>>>0,r||_(e,2,this.length),this[e]|this[e+1]<<8},c.prototype.readUint16BE=c.prototype.readUInt16BE=function(e,r){return e=e>>>0,r||_(e,2,this.length),this[e]<<8|this[e+1]},c.prototype.readUint32LE=c.prototype.readUInt32LE=function(e,r){return e=e>>>0,r||_(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216},c.prototype.readUint32BE=c.prototype.readUInt32BE=function(e,r){return e=e>>>0,r||_(e,4,this.length),this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])},c.prototype.readBigUInt64LE=Lt(function(e){e=e>>>0,ft(e,"offset");const r=this[e],u=this[e+7];(r===void 0||u===void 0)&&xt(e,this.length-8);const f=r+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24,d=this[++e]+this[++e]*2**8+this[++e]*2**16+u*2**24;return BigInt(f)+(BigInt(d)<<BigInt(32))}),c.prototype.readBigUInt64BE=Lt(function(e){e=e>>>0,ft(e,"offset");const r=this[e],u=this[e+7];(r===void 0||u===void 0)&&xt(e,this.length-8);const f=r*2**24+this[++e]*2**16+this[++e]*2**8+this[++e],d=this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+u;return(BigInt(f)<<BigInt(32))+BigInt(d)}),c.prototype.readIntLE=function(e,r,u){e=e>>>0,r=r>>>0,u||_(e,r,this.length);let f=this[e],d=1,g=0;for(;++g<r&&(d*=256);)f+=this[e+g]*d;return d*=128,f>=d&&(f-=Math.pow(2,8*r)),f},c.prototype.readIntBE=function(e,r,u){e=e>>>0,r=r>>>0,u||_(e,r,this.length);let f=r,d=1,g=this[e+--f];for(;f>0&&(d*=256);)g+=this[e+--f]*d;return d*=128,g>=d&&(g-=Math.pow(2,8*r)),g},c.prototype.readInt8=function(e,r){return e=e>>>0,r||_(e,1,this.length),this[e]&128?(255-this[e]+1)*-1:this[e]},c.prototype.readInt16LE=function(e,r){e=e>>>0,r||_(e,2,this.length);const u=this[e]|this[e+1]<<8;return u&32768?u|4294901760:u},c.prototype.readInt16BE=function(e,r){e=e>>>0,r||_(e,2,this.length);const u=this[e+1]|this[e]<<8;return u&32768?u|4294901760:u},c.prototype.readInt32LE=function(e,r){return e=e>>>0,r||_(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},c.prototype.readInt32BE=function(e,r){return e=e>>>0,r||_(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},c.prototype.readBigInt64LE=Lt(function(e){e=e>>>0,ft(e,"offset");const r=this[e],u=this[e+7];(r===void 0||u===void 0)&&xt(e,this.length-8);const f=this[e+4]+this[e+5]*2**8+this[e+6]*2**16+(u<<24);return(BigInt(f)<<BigInt(32))+BigInt(r+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24)}),c.prototype.readBigInt64BE=Lt(function(e){e=e>>>0,ft(e,"offset");const r=this[e],u=this[e+7];(r===void 0||u===void 0)&&xt(e,this.length-8);const f=(r<<24)+this[++e]*2**16+this[++e]*2**8+this[++e];return(BigInt(f)<<BigInt(32))+BigInt(this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+u)}),c.prototype.readFloatLE=function(e,r){return e=e>>>0,r||_(e,4,this.length),n.read(this,e,!0,23,4)},c.prototype.readFloatBE=function(e,r){return e=e>>>0,r||_(e,4,this.length),n.read(this,e,!1,23,4)},c.prototype.readDoubleLE=function(e,r){return e=e>>>0,r||_(e,8,this.length),n.read(this,e,!0,52,8)},c.prototype.readDoubleBE=function(e,r){return e=e>>>0,r||_(e,8,this.length),n.read(this,e,!1,52,8)};function O(o,e,r,u,f,d){if(!c.isBuffer(o))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>f||e<d)throw new RangeError('"value" argument is out of bounds');if(r+u>o.length)throw new RangeError("Index out of range")}c.prototype.writeUintLE=c.prototype.writeUIntLE=function(e,r,u,f){if(e=+e,r=r>>>0,u=u>>>0,!f){const F=Math.pow(2,8*u)-1;O(this,e,r,u,F,0)}let d=1,g=0;for(this[r]=e&255;++g<u&&(d*=256);)this[r+g]=e/d&255;return r+u},c.prototype.writeUintBE=c.prototype.writeUIntBE=function(e,r,u,f){if(e=+e,r=r>>>0,u=u>>>0,!f){const F=Math.pow(2,8*u)-1;O(this,e,r,u,F,0)}let d=u-1,g=1;for(this[r+d]=e&255;--d>=0&&(g*=256);)this[r+d]=e/g&255;return r+u},c.prototype.writeUint8=c.prototype.writeUInt8=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,1,255,0),this[r]=e&255,r+1},c.prototype.writeUint16LE=c.prototype.writeUInt16LE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,2,65535,0),this[r]=e&255,this[r+1]=e>>>8,r+2},c.prototype.writeUint16BE=c.prototype.writeUInt16BE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,2,65535,0),this[r]=e>>>8,this[r+1]=e&255,r+2},c.prototype.writeUint32LE=c.prototype.writeUInt32LE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,4,4294967295,0),this[r+3]=e>>>24,this[r+2]=e>>>16,this[r+1]=e>>>8,this[r]=e&255,r+4},c.prototype.writeUint32BE=c.prototype.writeUInt32BE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,4,4294967295,0),this[r]=e>>>24,this[r+1]=e>>>16,this[r+2]=e>>>8,this[r+3]=e&255,r+4};function et(o,e,r,u,f){Ct(e,u,f,o,r,7);let d=Number(e&BigInt(4294967295));o[r++]=d,d=d>>8,o[r++]=d,d=d>>8,o[r++]=d,d=d>>8,o[r++]=d;let g=Number(e>>BigInt(32)&BigInt(4294967295));return o[r++]=g,g=g>>8,o[r++]=g,g=g>>8,o[r++]=g,g=g>>8,o[r++]=g,r}function rt(o,e,r,u,f){Ct(e,u,f,o,r,7);let d=Number(e&BigInt(4294967295));o[r+7]=d,d=d>>8,o[r+6]=d,d=d>>8,o[r+5]=d,d=d>>8,o[r+4]=d;let g=Number(e>>BigInt(32)&BigInt(4294967295));return o[r+3]=g,g=g>>8,o[r+2]=g,g=g>>8,o[r+1]=g,g=g>>8,o[r]=g,r+8}c.prototype.writeBigUInt64LE=Lt(function(e,r=0){return et(this,e,r,BigInt(0),BigInt("0xffffffffffffffff"))}),c.prototype.writeBigUInt64BE=Lt(function(e,r=0){return rt(this,e,r,BigInt(0),BigInt("0xffffffffffffffff"))}),c.prototype.writeIntLE=function(e,r,u,f){if(e=+e,r=r>>>0,!f){const J=Math.pow(2,8*u-1);O(this,e,r,u,J-1,-J)}let d=0,g=1,F=0;for(this[r]=e&255;++d<u&&(g*=256);)e<0&&F===0&&this[r+d-1]!==0&&(F=1),this[r+d]=(e/g>>0)-F&255;return r+u},c.prototype.writeIntBE=function(e,r,u,f){if(e=+e,r=r>>>0,!f){const J=Math.pow(2,8*u-1);O(this,e,r,u,J-1,-J)}let d=u-1,g=1,F=0;for(this[r+d]=e&255;--d>=0&&(g*=256);)e<0&&F===0&&this[r+d+1]!==0&&(F=1),this[r+d]=(e/g>>0)-F&255;return r+u},c.prototype.writeInt8=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,1,127,-128),e<0&&(e=255+e+1),this[r]=e&255,r+1},c.prototype.writeInt16LE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,2,32767,-32768),this[r]=e&255,this[r+1]=e>>>8,r+2},c.prototype.writeInt16BE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,2,32767,-32768),this[r]=e>>>8,this[r+1]=e&255,r+2},c.prototype.writeInt32LE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,4,2147483647,-2147483648),this[r]=e&255,this[r+1]=e>>>8,this[r+2]=e>>>16,this[r+3]=e>>>24,r+4},c.prototype.writeInt32BE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[r]=e>>>24,this[r+1]=e>>>16,this[r+2]=e>>>8,this[r+3]=e&255,r+4},c.prototype.writeBigInt64LE=Lt(function(e,r=0){return et(this,e,r,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),c.prototype.writeBigInt64BE=Lt(function(e,r=0){return rt(this,e,r,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function ht(o,e,r,u,f,d){if(r+u>o.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function ot(o,e,r,u,f){return e=+e,r=r>>>0,f||ht(o,e,r,4),n.write(o,e,r,u,23,4),r+4}c.prototype.writeFloatLE=function(e,r,u){return ot(this,e,r,!0,u)},c.prototype.writeFloatBE=function(e,r,u){return ot(this,e,r,!1,u)};function ut(o,e,r,u,f){return e=+e,r=r>>>0,f||ht(o,e,r,8),n.write(o,e,r,u,52,8),r+8}c.prototype.writeDoubleLE=function(e,r,u){return ut(this,e,r,!0,u)},c.prototype.writeDoubleBE=function(e,r,u){return ut(this,e,r,!1,u)},c.prototype.copy=function(e,r,u,f){if(!c.isBuffer(e))throw new TypeError("argument should be a Buffer");if(u||(u=0),!f&&f!==0&&(f=this.length),r>=e.length&&(r=e.length),r||(r=0),f>0&&f<u&&(f=u),f===u||e.length===0||this.length===0)return 0;if(r<0)throw new RangeError("targetStart out of bounds");if(u<0||u>=this.length)throw new RangeError("Index out of range");if(f<0)throw new RangeError("sourceEnd out of bounds");f>this.length&&(f=this.length),e.length-r<f-u&&(f=e.length-r+u);const d=f-u;return this===e&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(r,u,f):Uint8Array.prototype.set.call(e,this.subarray(u,f),r),d},c.prototype.fill=function(e,r,u,f){if(typeof e=="string"){if(typeof r=="string"?(f=r,r=0,u=this.length):typeof u=="string"&&(f=u,u=this.length),f!==void 0&&typeof f!="string")throw new TypeError("encoding must be a string");if(typeof f=="string"&&!c.isEncoding(f))throw new TypeError("Unknown encoding: "+f);if(e.length===1){const g=e.charCodeAt(0);(f==="utf8"&&g<128||f==="latin1")&&(e=g)}}else typeof e=="number"?e=e&255:typeof e=="boolean"&&(e=Number(e));if(r<0||this.length<r||this.length<u)throw new RangeError("Out of range index");if(u<=r)return this;r=r>>>0,u=u===void 0?this.length:u>>>0,e||(e=0);let d;if(typeof e=="number")for(d=r;d<u;++d)this[d]=e;else{const g=c.isBuffer(e)?e:c.from(e,f),F=g.length;if(F===0)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(d=0;d<u-r;++d)this[d+r]=g[d%F]}return this};const dt={};function wt(o,e,r){dt[o]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:e.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${o}]`,this.stack,delete this.name}get code(){return o}set code(f){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:f,writable:!0})}toString(){return`${this.name} [${o}]: ${this.message}`}}}wt("ERR_BUFFER_OUT_OF_BOUNDS",function(o){return o?`${o} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),wt("ERR_INVALID_ARG_TYPE",function(o,e){return`The "${o}" argument must be of type number. Received type ${typeof e}`},TypeError),wt("ERR_OUT_OF_RANGE",function(o,e,r){let u=`The value of "${o}" is out of range.`,f=r;return Number.isInteger(r)&&Math.abs(r)>2**32?f=It(String(r)):typeof r=="bigint"&&(f=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(f=It(f)),f+="n"),u+=` It must be ${e}. Received ${f}`,u},RangeError);function It(o){let e="",r=o.length;const u=o[0]==="-"?1:0;for(;r>=u+4;r-=3)e=`_${o.slice(r-3,r)}${e}`;return`${o.slice(0,r)}${e}`}function Ut(o,e,r){ft(e,"offset"),(o[e]===void 0||o[e+r]===void 0)&&xt(e,o.length-(r+1))}function Ct(o,e,r,u,f,d){if(o>r||o<e){const g=typeof e=="bigint"?"n":"";let F;throw d>3?e===0||e===BigInt(0)?F=`>= 0${g} and < 2${g} ** ${(d+1)*8}${g}`:F=`>= -(2${g} ** ${(d+1)*8-1}${g}) and < 2 ** ${(d+1)*8-1}${g}`:F=`>= ${e}${g} and <= ${r}${g}`,new dt.ERR_OUT_OF_RANGE("value",F,o)}Ut(u,f,d)}function ft(o,e){if(typeof o!="number")throw new dt.ERR_INVALID_ARG_TYPE(e,"number",o)}function xt(o,e,r){throw Math.floor(o)!==o?(ft(o,r),new dt.ERR_OUT_OF_RANGE(r||"offset","an integer",o)):e<0?new dt.ERR_BUFFER_OUT_OF_BOUNDS:new dt.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${e}`,o)}const Jt=/[^+/0-9A-Za-z-_]/g;function se(o){if(o=o.split("=")[0],o=o.trim().replace(Jt,""),o.length<2)return"";for(;o.length%4!==0;)o=o+"=";return o}function ne(o,e){e=e||1/0;let r;const u=o.length;let f=null;const d=[];for(let g=0;g<u;++g){if(r=o.charCodeAt(g),r>55295&&r<57344){if(!f){if(r>56319){(e-=3)>-1&&d.push(239,191,189);continue}else if(g+1===u){(e-=3)>-1&&d.push(239,191,189);continue}f=r;continue}if(r<56320){(e-=3)>-1&&d.push(239,191,189),f=r;continue}r=(f-55296<<10|r-56320)+65536}else f&&(e-=3)>-1&&d.push(239,191,189);if(f=null,r<128){if((e-=1)<0)break;d.push(r)}else if(r<2048){if((e-=2)<0)break;d.push(r>>6|192,r&63|128)}else if(r<65536){if((e-=3)<0)break;d.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((e-=4)<0)break;d.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return d}function qe(o){const e=[];for(let r=0;r<o.length;++r)e.push(o.charCodeAt(r)&255);return e}function De(o,e){let r,u,f;const d=[];for(let g=0;g<o.length&&!((e-=2)<0);++g)r=o.charCodeAt(g),u=r>>8,f=r%256,d.push(f),d.push(u);return d}function fe(o){return t.toByteArray(se(o))}function Qt(o,e,r,u){let f;for(f=0;f<u&&!(f+r>=e.length||f>=o.length);++f)e[f+r]=o[f];return f}function bt(o,e){return o instanceof e||o!=null&&o.constructor!=null&&o.constructor.name!=null&&o.constructor.name===e.name}function re(o){return o!==o}const de=function(){const o="0123456789abcdef",e=new Array(256);for(let r=0;r<16;++r){const u=r*16;for(let f=0;f<16;++f)e[u+f]=o[r]+o[f]}return e}();function Lt(o){return typeof BigInt>"u"?xe:o}function xe(){throw new Error("BigInt not supported")}})(ct);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const br=BigInt(0),nn=BigInt(1),Ei=BigInt(2),rn=a=>a instanceof Uint8Array,Ii=Array.from({length:256},(a,t)=>t.toString(16).padStart(2,"0"));function me(a){if(!rn(a))throw new Error("Uint8Array expected");let t="";for(let n=0;n<a.length;n++)t+=Ii[a[n]];return t}function Br(a){const t=a.toString(16);return t.length&1?`0${t}`:t}function Tn(a){if(typeof a!="string")throw new Error("hex string expected, got "+typeof a);return BigInt(a===""?"0":`0x${a}`)}function Te(a){if(typeof a!="string")throw new Error("hex string expected, got "+typeof a);const t=a.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(t/2);for(let i=0;i<n.length;i++){const s=i*2,l=a.slice(s,s+2),h=Number.parseInt(l,16);if(Number.isNaN(h)||h<0)throw new Error("Invalid byte sequence");n[i]=h}return n}function ye(a){return Tn(me(a))}function Re(a){if(!rn(a))throw new Error("Uint8Array expected");return Tn(me(Uint8Array.from(a).reverse()))}function Ue(a,t){return Te(a.toString(16).padStart(t*2,"0"))}function We(a,t){return Ue(a,t).reverse()}function xi(a){return Te(Br(a))}function vt(a,t,n){let i;if(typeof t=="string")try{i=Te(t)}catch(l){throw new Error(`${a} must be valid hex string, got "${t}". Cause: ${l}`)}else if(rn(t))i=Uint8Array.from(t);else throw new Error(`${a} must be hex string or Uint8Array`);const s=i.length;if(typeof n=="number"&&s!==n)throw new Error(`${a} expected ${n} bytes, got ${s}`);return i}function be(...a){const t=new Uint8Array(a.reduce((i,s)=>i+s.length,0));let n=0;return a.forEach(i=>{if(!rn(i))throw new Error("Uint8Array expected");t.set(i,n),n+=i.length}),t}function Si(a,t){if(a.length!==t.length)return!1;for(let n=0;n<a.length;n++)if(a[n]!==t[n])return!1;return!0}function Ai(a){if(typeof a!="string")throw new Error(`utf8ToBytes expected string, got ${typeof a}`);return new Uint8Array(new TextEncoder().encode(a))}function ki(a){let t;for(t=0;a>br;a>>=nn,t+=1);return t}function Ri(a,t){return a>>BigInt(t)&nn}const _i=(a,t,n)=>a|(n?nn:br)<<BigInt(t),Un=a=>(Ei<<BigInt(a-1))-nn,ln=a=>new Uint8Array(a),jn=a=>Uint8Array.from(a);function Er(a,t,n){if(typeof a!="number"||a<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let i=ln(a),s=ln(a),l=0;const h=()=>{i.fill(1),s.fill(0),l=0},c=(...I)=>n(s,i,...I),p=(I=ln())=>{s=c(jn([0]),I),i=c(),I.length!==0&&(s=c(jn([1]),I),i=c())},w=()=>{if(l++>=1e3)throw new Error("drbg: tried 1000 values");let I=0;const N=[];for(;I<t;){i=c();const R=i.slice();N.push(R),I+=i.length}return be(...N)};return(I,N)=>{h(),p(I);let R;for(;!(R=N(w()));)p();return h(),R}}const Ti={bigint:a=>typeof a=="bigint",function:a=>typeof a=="function",boolean:a=>typeof a=="boolean",string:a=>typeof a=="string",stringOrUint8Array:a=>typeof a=="string"||a instanceof Uint8Array,isSafeInteger:a=>Number.isSafeInteger(a),array:a=>Array.isArray(a),field:(a,t)=>t.Fp.isValid(a),hash:a=>typeof a=="function"&&Number.isSafeInteger(a.outputLen)};function Fe(a,t,n={}){const i=(s,l,h)=>{const c=Ti[l];if(typeof c!="function")throw new Error(`Invalid validator "${l}", expected function`);const p=a[s];if(!(h&&p===void 0)&&!c(p,a))throw new Error(`Invalid param ${String(s)}=${p} (${typeof p}), expected ${l}`)};for(const[s,l]of Object.entries(t))i(s,l,!1);for(const[s,l]of Object.entries(n))i(s,l,!0);return a}const Ui=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Ri,bitLen:ki,bitMask:Un,bitSet:_i,bytesToHex:me,bytesToNumberBE:ye,bytesToNumberLE:Re,concatBytes:be,createHmacDrbg:Er,ensureBytes:vt,equalBytes:Si,hexToBytes:Te,hexToNumber:Tn,numberToBytesBE:Ue,numberToBytesLE:We,numberToHexUnpadded:Br,numberToVarBytesBE:xi,utf8ToBytes:Ai,validateObject:Fe},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qt=BigInt(0),At=BigInt(1),pe=BigInt(2),Ci=BigInt(3),yn=BigInt(4),Zn=BigInt(5),Yn=BigInt(8);BigInt(9);BigInt(16);function Et(a,t){const n=a%t;return n>=qt?n:t+n}function Li(a,t,n){if(n<=qt||t<qt)throw new Error("Expected power/modulo > 0");if(n===At)return qt;let i=At;for(;t>qt;)t&At&&(i=i*a%n),a=a*a%n,t>>=At;return i}function kt(a,t,n){let i=a;for(;t-- >qt;)i*=i,i%=n;return i}function wn(a,t){if(a===qt||t<=qt)throw new Error(`invert: expected positive integers, got n=${a} mod=${t}`);let n=Et(a,t),i=t,s=qt,l=At;for(;n!==qt;){const c=i/n,p=i%n,w=s-l*c;i=n,n=p,s=l,l=w}if(i!==At)throw new Error("invert: does not exist");return Et(s,t)}function Fi(a){const t=(a-At)/pe;let n,i,s;for(n=a-At,i=0;n%pe===qt;n/=pe,i++);for(s=pe;s<a&&Li(s,t,a)!==a-At;s++);if(i===1){const h=(a+At)/yn;return function(p,w){const m=p.pow(w,h);if(!p.eql(p.sqr(m),w))throw new Error("Cannot find square root");return m}}const l=(n+At)/pe;return function(c,p){if(c.pow(p,t)===c.neg(c.ONE))throw new Error("Cannot find square root");let w=i,m=c.pow(c.mul(c.ONE,s),n),I=c.pow(p,l),N=c.pow(p,n);for(;!c.eql(N,c.ONE);){if(c.eql(N,c.ZERO))return c.ZERO;let R=1;for(let y=c.sqr(N);R<w&&!c.eql(y,c.ONE);R++)y=c.sqr(y);const x=c.pow(m,At<<BigInt(w-R-1));m=c.sqr(x),I=c.mul(I,x),N=c.mul(N,m),w=R}return I}}function Ni(a){if(a%yn===Ci){const t=(a+At)/yn;return function(i,s){const l=i.pow(s,t);if(!i.eql(i.sqr(l),s))throw new Error("Cannot find square root");return l}}if(a%Yn===Zn){const t=(a-Zn)/Yn;return function(i,s){const l=i.mul(s,pe),h=i.pow(l,t),c=i.mul(s,h),p=i.mul(i.mul(c,pe),h),w=i.mul(c,i.sub(p,i.ONE));if(!i.eql(i.sqr(w),s))throw new Error("Cannot find square root");return w}}return Fi(a)}const Pi=(a,t)=>(Et(a,t)&At)===At,Oi=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function vi(a){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=Oi.reduce((i,s)=>(i[s]="function",i),t);return Fe(a,n)}function qi(a,t,n){if(n<qt)throw new Error("Expected power > 0");if(n===qt)return a.ONE;if(n===At)return t;let i=a.ONE,s=t;for(;n>qt;)n&At&&(i=a.mul(i,s)),s=a.sqr(s),n>>=At;return i}function Di(a,t){const n=new Array(t.length),i=t.reduce((l,h,c)=>a.is0(h)?l:(n[c]=l,a.mul(l,h)),a.ONE),s=a.inv(i);return t.reduceRight((l,h,c)=>a.is0(h)?l:(n[c]=a.mul(l,n[c]),a.mul(l,h)),s),n}function Ir(a,t){const n=t!==void 0?t:a.toString(2).length,i=Math.ceil(n/8);return{nBitLength:n,nByteLength:i}}function xr(a,t,n=!1,i={}){if(a<=qt)throw new Error(`Expected Field ORDER > 0, got ${a}`);const{nBitLength:s,nByteLength:l}=Ir(a,t);if(l>2048)throw new Error("Field lengths over 2048 bytes are not supported");const h=Ni(a),c=Object.freeze({ORDER:a,BITS:s,BYTES:l,MASK:Un(s),ZERO:qt,ONE:At,create:p=>Et(p,a),isValid:p=>{if(typeof p!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof p}`);return qt<=p&&p<a},is0:p=>p===qt,isOdd:p=>(p&At)===At,neg:p=>Et(-p,a),eql:(p,w)=>p===w,sqr:p=>Et(p*p,a),add:(p,w)=>Et(p+w,a),sub:(p,w)=>Et(p-w,a),mul:(p,w)=>Et(p*w,a),pow:(p,w)=>qi(c,p,w),div:(p,w)=>Et(p*wn(w,a),a),sqrN:p=>p*p,addN:(p,w)=>p+w,subN:(p,w)=>p-w,mulN:(p,w)=>p*w,inv:p=>wn(p,a),sqrt:i.sqrt||(p=>h(c,p)),invertBatch:p=>Di(c,p),cmov:(p,w,m)=>m?w:p,toBytes:p=>n?We(p,l):Ue(p,l),fromBytes:p=>{if(p.length!==l)throw new Error(`Fp.fromBytes: expected ${l}, got ${p.length}`);return n?Re(p):ye(p)}});return Object.freeze(c)}function Ki(a,t){if(!a.isOdd)throw new Error("Field doesn't have isOdd");const n=a.sqrt(t);return a.isOdd(n)?a.neg(n):n}function Sr(a){if(typeof a!="bigint")throw new Error("field order must be bigint");const t=a.toString(2).length;return Math.ceil(t/8)}function Ar(a){const t=Sr(a);return t+Math.ceil(t/2)}function $i(a,t,n=!1){const i=a.length,s=Sr(t),l=Ar(t);if(i<16||i<l||i>1024)throw new Error(`expected ${l}-1024 bytes of input, got ${i}`);const h=n?ye(a):Re(a),c=Et(h,t-At)+At;return n?We(c,s):Ue(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zi=BigInt(0),hn=BigInt(1);function kr(a,t){const n=(s,l)=>{const h=l.negate();return s?h:l},i=s=>{const l=Math.ceil(t/s)+1,h=2**(s-1);return{windows:l,windowSize:h}};return{constTimeNegate:n,unsafeLadder(s,l){let h=a.ZERO,c=s;for(;l>zi;)l&hn&&(h=h.add(c)),c=c.double(),l>>=hn;return h},precomputeWindow(s,l){const{windows:h,windowSize:c}=i(l),p=[];let w=s,m=w;for(let I=0;I<h;I++){m=w,p.push(m);for(let N=1;N<c;N++)m=m.add(w),p.push(m);w=m.double()}return p},wNAF(s,l,h){const{windows:c,windowSize:p}=i(s);let w=a.ZERO,m=a.BASE;const I=BigInt(2**s-1),N=2**s,R=BigInt(s);for(let x=0;x<c;x++){const y=x*p;let E=Number(h&I);h>>=R,E>p&&(E-=N,h+=hn);const A=y,K=y+Math.abs(E)-1,G=x%2!==0,it=E<0;E===0?m=m.add(n(G,l[A])):w=w.add(n(it,l[K]))}return{p:w,f:m}},wNAFCached(s,l,h,c){const p=s._WINDOW_SIZE||1;let w=l.get(s);return w||(w=this.precomputeWindow(s,p),p!==1&&l.set(s,c(w))),this.wNAF(p,w,h)}}}function Cn(a){return vi(a.Fp),Fe(a,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ir(a.n,a.nBitLength),...a,p:a.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const te=BigInt(0),Gt=BigInt(1),je=BigInt(2),Mi=BigInt(8),Wi={zip215:!0};function Gi(a){const t=Cn(a);return Fe(a,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function Ln(a){const t=Gi(a),{Fp:n,n:i,prehash:s,hash:l,randomBytes:h,nByteLength:c,h:p}=t,w=je<<BigInt(c*8)-Gt,m=n.create,I=t.uvRatio||((C,S)=>{try{return{isValid:!0,value:n.sqrt(C*n.inv(S))}}catch{return{isValid:!1,value:te}}}),N=t.adjustScalarBytes||(C=>C),R=t.domain||((C,S,D)=>{if(S.length||D)throw new Error("Contexts/pre-hash are not supported");return C}),x=C=>typeof C=="bigint"&&te<C,y=(C,S)=>x(C)&&x(S)&&C<S,E=C=>C===te||y(C,w);function A(C,S){if(y(C,S))return C;throw new Error(`Expected valid scalar < ${S}, got ${typeof C} ${C}`)}function K(C){return C===te?C:A(C,i)}const G=new Map;function it(C){if(!(C instanceof P))throw new Error("ExtendedPoint expected")}class P{constructor(S,D,_,O){if(this.ex=S,this.ey=D,this.ez=_,this.et=O,!E(S))throw new Error("x required");if(!E(D))throw new Error("y required");if(!E(_))throw new Error("z required");if(!E(O))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(S){if(S instanceof P)throw new Error("extended point not allowed");const{x:D,y:_}=S||{};if(!E(D)||!E(_))throw new Error("invalid affine point");return new P(D,_,Gt,m(D*_))}static normalizeZ(S){const D=n.invertBatch(S.map(_=>_.ez));return S.map((_,O)=>_.toAffine(D[O])).map(P.fromAffine)}_setWindowSize(S){this._WINDOW_SIZE=S,G.delete(this)}assertValidity(){const{a:S,d:D}=t;if(this.is0())throw new Error("bad point: ZERO");const{ex:_,ey:O,ez:et,et:rt}=this,ht=m(_*_),ot=m(O*O),ut=m(et*et),dt=m(ut*ut),wt=m(ht*S),It=m(ut*m(wt+ot)),Ut=m(dt+m(D*m(ht*ot)));if(It!==Ut)throw new Error("bad point: equation left != right (1)");const Ct=m(_*O),ft=m(et*rt);if(Ct!==ft)throw new Error("bad point: equation left != right (2)")}equals(S){it(S);const{ex:D,ey:_,ez:O}=this,{ex:et,ey:rt,ez:ht}=S,ot=m(D*ht),ut=m(et*O),dt=m(_*ht),wt=m(rt*O);return ot===ut&&dt===wt}is0(){return this.equals(P.ZERO)}negate(){return new P(m(-this.ex),this.ey,this.ez,m(-this.et))}double(){const{a:S}=t,{ex:D,ey:_,ez:O}=this,et=m(D*D),rt=m(_*_),ht=m(je*m(O*O)),ot=m(S*et),ut=D+_,dt=m(m(ut*ut)-et-rt),wt=ot+rt,It=wt-ht,Ut=ot-rt,Ct=m(dt*It),ft=m(wt*Ut),xt=m(dt*Ut),Jt=m(It*wt);return new P(Ct,ft,Jt,xt)}add(S){it(S);const{a:D,d:_}=t,{ex:O,ey:et,ez:rt,et:ht}=this,{ex:ot,ey:ut,ez:dt,et:wt}=S;if(D===BigInt(-1)){const bt=m((et-O)*(ut+ot)),re=m((et+O)*(ut-ot)),de=m(re-bt);if(de===te)return this.double();const Lt=m(rt*je*wt),xe=m(ht*je*dt),o=xe+Lt,e=re+bt,r=xe-Lt,u=m(o*de),f=m(e*r),d=m(o*r),g=m(de*e);return new P(u,f,g,d)}const It=m(O*ot),Ut=m(et*ut),Ct=m(ht*_*wt),ft=m(rt*dt),xt=m((O+et)*(ot+ut)-It-Ut),Jt=ft-Ct,se=ft+Ct,ne=m(Ut-D*It),qe=m(xt*Jt),De=m(se*ne),fe=m(xt*ne),Qt=m(Jt*se);return new P(qe,De,Qt,fe)}subtract(S){return this.add(S.negate())}wNAF(S){return tt.wNAFCached(this,G,S,P.normalizeZ)}multiply(S){const{p:D,f:_}=this.wNAF(A(S,i));return P.normalizeZ([D,_])[0]}multiplyUnsafe(S){let D=K(S);return D===te?j:this.equals(j)||D===Gt?this:this.equals(z)?this.wNAF(D).p:tt.unsafeLadder(this,D)}isSmallOrder(){return this.multiplyUnsafe(p).is0()}isTorsionFree(){return tt.unsafeLadder(this,i).is0()}toAffine(S){const{ex:D,ey:_,ez:O}=this,et=this.is0();S==null&&(S=et?Mi:n.inv(O));const rt=m(D*S),ht=m(_*S),ot=m(O*S);if(et)return{x:te,y:Gt};if(ot!==Gt)throw new Error("invZ was invalid");return{x:rt,y:ht}}clearCofactor(){const{h:S}=t;return S===Gt?this:this.multiplyUnsafe(S)}static fromHex(S,D=!1){const{d:_,a:O}=t,et=n.BYTES;S=vt("pointHex",S,et);const rt=S.slice(),ht=S[et-1];rt[et-1]=ht&-129;const ot=Re(rt);ot===te||(D?A(ot,w):A(ot,n.ORDER));const ut=m(ot*ot),dt=m(ut-Gt),wt=m(_*ut-O);let{isValid:It,value:Ut}=I(dt,wt);if(!It)throw new Error("Point.fromHex: invalid y coordinate");const Ct=(Ut&Gt)===Gt,ft=(ht&128)!==0;if(!D&&Ut===te&&ft)throw new Error("Point.fromHex: x=0 and x_0=1");return ft!==Ct&&(Ut=m(-Ut)),P.fromAffine({x:Ut,y:ot})}static fromPrivateKey(S){return at(S).point}toRawBytes(){const{x:S,y:D}=this.toAffine(),_=We(D,n.BYTES);return _[_.length-1]|=S&Gt?128:0,_}toHex(){return me(this.toRawBytes())}}P.BASE=new P(t.Gx,t.Gy,Gt,m(t.Gx*t.Gy)),P.ZERO=new P(te,Gt,Gt,te);const{BASE:z,ZERO:j}=P,tt=kr(P,c*8);function Pt(C){return Et(C,i)}function gt(C){return Pt(Re(C))}function at(C){const S=c;C=vt("private key",C,S);const D=vt("hashed private key",l(C),2*S),_=N(D.slice(0,S)),O=D.slice(S,2*S),et=gt(_),rt=z.multiply(et),ht=rt.toRawBytes();return{head:_,prefix:O,scalar:et,point:rt,pointBytes:ht}}function Ot(C){return at(C).pointBytes}function Tt(C=new Uint8Array,...S){const D=be(...S);return gt(l(R(D,vt("context",C),!!s)))}function $t(C,S,D={}){C=vt("message",C),s&&(C=s(C));const{prefix:_,scalar:O,pointBytes:et}=at(S),rt=Tt(D.context,_,C),ht=z.multiply(rt).toRawBytes(),ot=Tt(D.context,ht,et,C),ut=Pt(rt+ot*O);K(ut);const dt=be(ht,We(ut,n.BYTES));return vt("result",dt,c*2)}const U=Wi;function $(C,S,D,_=U){const{context:O,zip215:et}=_,rt=n.BYTES;C=vt("signature",C,2*rt),S=vt("message",S),s&&(S=s(S));const ht=Re(C.slice(rt,2*rt));let ot,ut,dt;try{ot=P.fromHex(D,et),ut=P.fromHex(C.slice(0,rt),et),dt=z.multiplyUnsafe(ht)}catch{return!1}if(!et&&ot.isSmallOrder())return!1;const wt=Tt(O,ut.toRawBytes(),ot.toRawBytes(),S);return ut.add(ot.multiplyUnsafe(wt)).subtract(dt).clearCofactor().equals(P.ZERO)}return z._setWindowSize(8),{CURVE:t,getPublicKey:Ot,sign:$t,verify:$,ExtendedPoint:P,utils:{getExtendedPublicKey:at,randomPrivateKey:()=>h(n.BYTES),precompute(C=8,S=P.BASE){return S._setWindowSize(C),S.multiply(BigInt(3)),S}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Fn=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Xn=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Hi=BigInt(1),mn=BigInt(2),Vi=BigInt(5),Jn=BigInt(10),ji=BigInt(20),Zi=BigInt(40),Qn=BigInt(80);function Yi(a){const t=Fn,i=a*a%t*a%t,s=kt(i,mn,t)*i%t,l=kt(s,Hi,t)*a%t,h=kt(l,Vi,t)*l%t,c=kt(h,Jn,t)*h%t,p=kt(c,ji,t)*c%t,w=kt(p,Zi,t)*p%t,m=kt(w,Qn,t)*w%t,I=kt(m,Qn,t)*w%t,N=kt(I,Jn,t)*h%t;return{pow_p_5_8:kt(N,mn,t)*a%t,b2:i}}function Xi(a){return a[0]&=248,a[31]&=127,a[31]|=64,a}function Ji(a,t){const n=Fn,i=Et(t*t*t,n),s=Et(i*i*t,n),l=Yi(a*s).pow_p_5_8;let h=Et(a*i*l,n);const c=Et(t*h*h,n),p=h,w=Et(h*Xn,n),m=c===a,I=c===Et(-a,n),N=c===Et(-a*Xn,n);return m&&(h=p),(I||N)&&(h=w),Pi(h,n)&&(h=Et(-h,n)),{isValid:m||I,value:h}}const ae=xr(Fn,void 0,!0),Nn={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:ae,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:wr,randomBytes:Me.randomBytes,adjustScalarBytes:Xi,uvRatio:Ji},Ne=Ln(Nn);function Rr(a,t,n){if(t.length>255)throw new Error("Context is too big");return Me.concatBytes(Me.utf8ToBytes("SigEd25519 no Ed25519 collisions"),new Uint8Array([n?1:0,t.length]),t,a)}({...Nn});({...Nn,prehash:wr});const Qi=(ae.ORDER+BigInt(3))/BigInt(8);ae.pow(mn,Qi);ae.sqrt(ae.neg(ae.ONE));(ae.ORDER-BigInt(5))/BigInt(8);BigInt(486662);Ki(ae,ae.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var B={},_r={};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(a){const t=gr,n=yr,i=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;a.Buffer=c,a.SlowBuffer=K,a.INSPECT_MAX_BYTES=50;const s=2147483647;a.kMaxLength=s,c.TYPED_ARRAY_SUPPORT=l(),!c.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function l(){try{const o=new Uint8Array(1),e={foo:function(){return 42}};return Object.setPrototypeOf(e,Uint8Array.prototype),Object.setPrototypeOf(o,e),o.foo()===42}catch{return!1}}Object.defineProperty(c.prototype,"parent",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.buffer}}),Object.defineProperty(c.prototype,"offset",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.byteOffset}});function h(o){if(o>s)throw new RangeError('The value "'+o+'" is invalid for option "size"');const e=new Uint8Array(o);return Object.setPrototypeOf(e,c.prototype),e}function c(o,e,r){if(typeof o=="number"){if(typeof e=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return I(o)}return p(o,e,r)}c.poolSize=8192;function p(o,e,r){if(typeof o=="string")return N(o,e);if(ArrayBuffer.isView(o))return x(o);if(o==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof o);if(bt(o,ArrayBuffer)||o&&bt(o.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(bt(o,SharedArrayBuffer)||o&&bt(o.buffer,SharedArrayBuffer)))return y(o,e,r);if(typeof o=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const u=o.valueOf&&o.valueOf();if(u!=null&&u!==o)return c.from(u,e,r);const f=E(o);if(f)return f;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof o[Symbol.toPrimitive]=="function")return c.from(o[Symbol.toPrimitive]("string"),e,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof o)}c.from=function(o,e,r){return p(o,e,r)},Object.setPrototypeOf(c.prototype,Uint8Array.prototype),Object.setPrototypeOf(c,Uint8Array);function w(o){if(typeof o!="number")throw new TypeError('"size" argument must be of type number');if(o<0)throw new RangeError('The value "'+o+'" is invalid for option "size"')}function m(o,e,r){return w(o),o<=0?h(o):e!==void 0?typeof r=="string"?h(o).fill(e,r):h(o).fill(e):h(o)}c.alloc=function(o,e,r){return m(o,e,r)};function I(o){return w(o),h(o<0?0:A(o)|0)}c.allocUnsafe=function(o){return I(o)},c.allocUnsafeSlow=function(o){return I(o)};function N(o,e){if((typeof e!="string"||e==="")&&(e="utf8"),!c.isEncoding(e))throw new TypeError("Unknown encoding: "+e);const r=G(o,e)|0;let u=h(r);const f=u.write(o,e);return f!==r&&(u=u.slice(0,f)),u}function R(o){const e=o.length<0?0:A(o.length)|0,r=h(e);for(let u=0;u<e;u+=1)r[u]=o[u]&255;return r}function x(o){if(bt(o,Uint8Array)){const e=new Uint8Array(o);return y(e.buffer,e.byteOffset,e.byteLength)}return R(o)}function y(o,e,r){if(e<0||o.byteLength<e)throw new RangeError('"offset" is outside of buffer bounds');if(o.byteLength<e+(r||0))throw new RangeError('"length" is outside of buffer bounds');let u;return e===void 0&&r===void 0?u=new Uint8Array(o):r===void 0?u=new Uint8Array(o,e):u=new Uint8Array(o,e,r),Object.setPrototypeOf(u,c.prototype),u}function E(o){if(c.isBuffer(o)){const e=A(o.length)|0,r=h(e);return r.length===0||o.copy(r,0,0,e),r}if(o.length!==void 0)return typeof o.length!="number"||re(o.length)?h(0):R(o);if(o.type==="Buffer"&&Array.isArray(o.data))return R(o.data)}function A(o){if(o>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return o|0}function K(o){return+o!=o&&(o=0),c.alloc(+o)}c.isBuffer=function(e){return e!=null&&e._isBuffer===!0&&e!==c.prototype},c.compare=function(e,r){if(bt(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),bt(r,Uint8Array)&&(r=c.from(r,r.offset,r.byteLength)),!c.isBuffer(e)||!c.isBuffer(r))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===r)return 0;let u=e.length,f=r.length;for(let d=0,g=Math.min(u,f);d<g;++d)if(e[d]!==r[d]){u=e[d],f=r[d];break}return u<f?-1:f<u?1:0},c.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(e,r){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(e.length===0)return c.alloc(0);let u;if(r===void 0)for(r=0,u=0;u<e.length;++u)r+=e[u].length;const f=c.allocUnsafe(r);let d=0;for(u=0;u<e.length;++u){let g=e[u];if(bt(g,Uint8Array))d+g.length>f.length?(c.isBuffer(g)||(g=c.from(g)),g.copy(f,d)):Uint8Array.prototype.set.call(f,g,d);else if(c.isBuffer(g))g.copy(f,d);else throw new TypeError('"list" argument must be an Array of Buffers');d+=g.length}return f};function G(o,e){if(c.isBuffer(o))return o.length;if(ArrayBuffer.isView(o)||bt(o,ArrayBuffer))return o.byteLength;if(typeof o!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof o);const r=o.length,u=arguments.length>2&&arguments[2]===!0;if(!u&&r===0)return 0;let f=!1;for(;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return ne(o).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return r*2;case"hex":return r>>>1;case"base64":return fe(o).length;default:if(f)return u?-1:ne(o).length;e=(""+e).toLowerCase(),f=!0}}c.byteLength=G;function it(o,e,r){let u=!1;if((e===void 0||e<0)&&(e=0),e>this.length||((r===void 0||r>this.length)&&(r=this.length),r<=0)||(r>>>=0,e>>>=0,r<=e))return"";for(o||(o="utf8");;)switch(o){case"hex":return S(this,e,r);case"utf8":case"utf-8":return $t(this,e,r);case"ascii":return nt(this,e,r);case"latin1":case"binary":return C(this,e,r);case"base64":return Tt(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return D(this,e,r);default:if(u)throw new TypeError("Unknown encoding: "+o);o=(o+"").toLowerCase(),u=!0}}c.prototype._isBuffer=!0;function P(o,e,r){const u=o[e];o[e]=o[r],o[r]=u}c.prototype.swap16=function(){const e=this.length;if(e%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let r=0;r<e;r+=2)P(this,r,r+1);return this},c.prototype.swap32=function(){const e=this.length;if(e%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let r=0;r<e;r+=4)P(this,r,r+3),P(this,r+1,r+2);return this},c.prototype.swap64=function(){const e=this.length;if(e%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let r=0;r<e;r+=8)P(this,r,r+7),P(this,r+1,r+6),P(this,r+2,r+5),P(this,r+3,r+4);return this},c.prototype.toString=function(){const e=this.length;return e===0?"":arguments.length===0?$t(this,0,e):it.apply(this,arguments)},c.prototype.toLocaleString=c.prototype.toString,c.prototype.equals=function(e){if(!c.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e?!0:c.compare(this,e)===0},c.prototype.inspect=function(){let e="";const r=a.INSPECT_MAX_BYTES;return e=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(e+=" ... "),"<Buffer "+e+">"},i&&(c.prototype[i]=c.prototype.inspect),c.prototype.compare=function(e,r,u,f,d){if(bt(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),!c.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(r===void 0&&(r=0),u===void 0&&(u=e?e.length:0),f===void 0&&(f=0),d===void 0&&(d=this.length),r<0||u>e.length||f<0||d>this.length)throw new RangeError("out of range index");if(f>=d&&r>=u)return 0;if(f>=d)return-1;if(r>=u)return 1;if(r>>>=0,u>>>=0,f>>>=0,d>>>=0,this===e)return 0;let g=d-f,F=u-r;const J=Math.min(g,F),Z=this.slice(f,d),Q=e.slice(r,u);for(let H=0;H<J;++H)if(Z[H]!==Q[H]){g=Z[H],F=Q[H];break}return g<F?-1:F<g?1:0};function z(o,e,r,u,f){if(o.length===0)return-1;if(typeof r=="string"?(u=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,re(r)&&(r=f?0:o.length-1),r<0&&(r=o.length+r),r>=o.length){if(f)return-1;r=o.length-1}else if(r<0)if(f)r=0;else return-1;if(typeof e=="string"&&(e=c.from(e,u)),c.isBuffer(e))return e.length===0?-1:j(o,e,r,u,f);if(typeof e=="number")return e=e&255,typeof Uint8Array.prototype.indexOf=="function"?f?Uint8Array.prototype.indexOf.call(o,e,r):Uint8Array.prototype.lastIndexOf.call(o,e,r):j(o,[e],r,u,f);throw new TypeError("val must be string, number or Buffer")}function j(o,e,r,u,f){let d=1,g=o.length,F=e.length;if(u!==void 0&&(u=String(u).toLowerCase(),u==="ucs2"||u==="ucs-2"||u==="utf16le"||u==="utf-16le")){if(o.length<2||e.length<2)return-1;d=2,g/=2,F/=2,r/=2}function J(Q,H){return d===1?Q[H]:Q.readUInt16BE(H*d)}let Z;if(f){let Q=-1;for(Z=r;Z<g;Z++)if(J(o,Z)===J(e,Q===-1?0:Z-Q)){if(Q===-1&&(Q=Z),Z-Q+1===F)return Q*d}else Q!==-1&&(Z-=Z-Q),Q=-1}else for(r+F>g&&(r=g-F),Z=r;Z>=0;Z--){let Q=!0;for(let H=0;H<F;H++)if(J(o,Z+H)!==J(e,H)){Q=!1;break}if(Q)return Z}return-1}c.prototype.includes=function(e,r,u){return this.indexOf(e,r,u)!==-1},c.prototype.indexOf=function(e,r,u){return z(this,e,r,u,!0)},c.prototype.lastIndexOf=function(e,r,u){return z(this,e,r,u,!1)};function tt(o,e,r,u){r=Number(r)||0;const f=o.length-r;u?(u=Number(u),u>f&&(u=f)):u=f;const d=e.length;u>d/2&&(u=d/2);let g;for(g=0;g<u;++g){const F=parseInt(e.substr(g*2,2),16);if(re(F))return g;o[r+g]=F}return g}function Pt(o,e,r,u){return Qt(ne(e,o.length-r),o,r,u)}function gt(o,e,r,u){return Qt(qe(e),o,r,u)}function at(o,e,r,u){return Qt(fe(e),o,r,u)}function Ot(o,e,r,u){return Qt(De(e,o.length-r),o,r,u)}c.prototype.write=function(e,r,u,f){if(r===void 0)f="utf8",u=this.length,r=0;else if(u===void 0&&typeof r=="string")f=r,u=this.length,r=0;else if(isFinite(r))r=r>>>0,isFinite(u)?(u=u>>>0,f===void 0&&(f="utf8")):(f=u,u=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const d=this.length-r;if((u===void 0||u>d)&&(u=d),e.length>0&&(u<0||r<0)||r>this.length)throw new RangeError("Attempt to write outside buffer bounds");f||(f="utf8");let g=!1;for(;;)switch(f){case"hex":return tt(this,e,r,u);case"utf8":case"utf-8":return Pt(this,e,r,u);case"ascii":case"latin1":case"binary":return gt(this,e,r,u);case"base64":return at(this,e,r,u);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Ot(this,e,r,u);default:if(g)throw new TypeError("Unknown encoding: "+f);f=(""+f).toLowerCase(),g=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function Tt(o,e,r){return e===0&&r===o.length?t.fromByteArray(o):t.fromByteArray(o.slice(e,r))}function $t(o,e,r){r=Math.min(o.length,r);const u=[];let f=e;for(;f<r;){const d=o[f];let g=null,F=d>239?4:d>223?3:d>191?2:1;if(f+F<=r){let J,Z,Q,H;switch(F){case 1:d<128&&(g=d);break;case 2:J=o[f+1],(J&192)===128&&(H=(d&31)<<6|J&63,H>127&&(g=H));break;case 3:J=o[f+1],Z=o[f+2],(J&192)===128&&(Z&192)===128&&(H=(d&15)<<12|(J&63)<<6|Z&63,H>2047&&(H<55296||H>57343)&&(g=H));break;case 4:J=o[f+1],Z=o[f+2],Q=o[f+3],(J&192)===128&&(Z&192)===128&&(Q&192)===128&&(H=(d&15)<<18|(J&63)<<12|(Z&63)<<6|Q&63,H>65535&&H<1114112&&(g=H))}}g===null?(g=65533,F=1):g>65535&&(g-=65536,u.push(g>>>10&1023|55296),g=56320|g&1023),u.push(g),f+=F}return $(u)}const U=4096;function $(o){const e=o.length;if(e<=U)return String.fromCharCode.apply(String,o);let r="",u=0;for(;u<e;)r+=String.fromCharCode.apply(String,o.slice(u,u+=U));return r}function nt(o,e,r){let u="";r=Math.min(o.length,r);for(let f=e;f<r;++f)u+=String.fromCharCode(o[f]&127);return u}function C(o,e,r){let u="";r=Math.min(o.length,r);for(let f=e;f<r;++f)u+=String.fromCharCode(o[f]);return u}function S(o,e,r){const u=o.length;(!e||e<0)&&(e=0),(!r||r<0||r>u)&&(r=u);let f="";for(let d=e;d<r;++d)f+=de[o[d]];return f}function D(o,e,r){const u=o.slice(e,r);let f="";for(let d=0;d<u.length-1;d+=2)f+=String.fromCharCode(u[d]+u[d+1]*256);return f}c.prototype.slice=function(e,r){const u=this.length;e=~~e,r=r===void 0?u:~~r,e<0?(e+=u,e<0&&(e=0)):e>u&&(e=u),r<0?(r+=u,r<0&&(r=0)):r>u&&(r=u),r<e&&(r=e);const f=this.subarray(e,r);return Object.setPrototypeOf(f,c.prototype),f};function _(o,e,r){if(o%1!==0||o<0)throw new RangeError("offset is not uint");if(o+e>r)throw new RangeError("Trying to access beyond buffer length")}c.prototype.readUintLE=c.prototype.readUIntLE=function(e,r,u){e=e>>>0,r=r>>>0,u||_(e,r,this.length);let f=this[e],d=1,g=0;for(;++g<r&&(d*=256);)f+=this[e+g]*d;return f},c.prototype.readUintBE=c.prototype.readUIntBE=function(e,r,u){e=e>>>0,r=r>>>0,u||_(e,r,this.length);let f=this[e+--r],d=1;for(;r>0&&(d*=256);)f+=this[e+--r]*d;return f},c.prototype.readUint8=c.prototype.readUInt8=function(e,r){return e=e>>>0,r||_(e,1,this.length),this[e]},c.prototype.readUint16LE=c.prototype.readUInt16LE=function(e,r){return e=e>>>0,r||_(e,2,this.length),this[e]|this[e+1]<<8},c.prototype.readUint16BE=c.prototype.readUInt16BE=function(e,r){return e=e>>>0,r||_(e,2,this.length),this[e]<<8|this[e+1]},c.prototype.readUint32LE=c.prototype.readUInt32LE=function(e,r){return e=e>>>0,r||_(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216},c.prototype.readUint32BE=c.prototype.readUInt32BE=function(e,r){return e=e>>>0,r||_(e,4,this.length),this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])},c.prototype.readBigUInt64LE=Lt(function(e){e=e>>>0,ft(e,"offset");const r=this[e],u=this[e+7];(r===void 0||u===void 0)&&xt(e,this.length-8);const f=r+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24,d=this[++e]+this[++e]*2**8+this[++e]*2**16+u*2**24;return BigInt(f)+(BigInt(d)<<BigInt(32))}),c.prototype.readBigUInt64BE=Lt(function(e){e=e>>>0,ft(e,"offset");const r=this[e],u=this[e+7];(r===void 0||u===void 0)&&xt(e,this.length-8);const f=r*2**24+this[++e]*2**16+this[++e]*2**8+this[++e],d=this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+u;return(BigInt(f)<<BigInt(32))+BigInt(d)}),c.prototype.readIntLE=function(e,r,u){e=e>>>0,r=r>>>0,u||_(e,r,this.length);let f=this[e],d=1,g=0;for(;++g<r&&(d*=256);)f+=this[e+g]*d;return d*=128,f>=d&&(f-=Math.pow(2,8*r)),f},c.prototype.readIntBE=function(e,r,u){e=e>>>0,r=r>>>0,u||_(e,r,this.length);let f=r,d=1,g=this[e+--f];for(;f>0&&(d*=256);)g+=this[e+--f]*d;return d*=128,g>=d&&(g-=Math.pow(2,8*r)),g},c.prototype.readInt8=function(e,r){return e=e>>>0,r||_(e,1,this.length),this[e]&128?(255-this[e]+1)*-1:this[e]},c.prototype.readInt16LE=function(e,r){e=e>>>0,r||_(e,2,this.length);const u=this[e]|this[e+1]<<8;return u&32768?u|4294901760:u},c.prototype.readInt16BE=function(e,r){e=e>>>0,r||_(e,2,this.length);const u=this[e+1]|this[e]<<8;return u&32768?u|4294901760:u},c.prototype.readInt32LE=function(e,r){return e=e>>>0,r||_(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},c.prototype.readInt32BE=function(e,r){return e=e>>>0,r||_(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},c.prototype.readBigInt64LE=Lt(function(e){e=e>>>0,ft(e,"offset");const r=this[e],u=this[e+7];(r===void 0||u===void 0)&&xt(e,this.length-8);const f=this[e+4]+this[e+5]*2**8+this[e+6]*2**16+(u<<24);return(BigInt(f)<<BigInt(32))+BigInt(r+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24)}),c.prototype.readBigInt64BE=Lt(function(e){e=e>>>0,ft(e,"offset");const r=this[e],u=this[e+7];(r===void 0||u===void 0)&&xt(e,this.length-8);const f=(r<<24)+this[++e]*2**16+this[++e]*2**8+this[++e];return(BigInt(f)<<BigInt(32))+BigInt(this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+u)}),c.prototype.readFloatLE=function(e,r){return e=e>>>0,r||_(e,4,this.length),n.read(this,e,!0,23,4)},c.prototype.readFloatBE=function(e,r){return e=e>>>0,r||_(e,4,this.length),n.read(this,e,!1,23,4)},c.prototype.readDoubleLE=function(e,r){return e=e>>>0,r||_(e,8,this.length),n.read(this,e,!0,52,8)},c.prototype.readDoubleBE=function(e,r){return e=e>>>0,r||_(e,8,this.length),n.read(this,e,!1,52,8)};function O(o,e,r,u,f,d){if(!c.isBuffer(o))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>f||e<d)throw new RangeError('"value" argument is out of bounds');if(r+u>o.length)throw new RangeError("Index out of range")}c.prototype.writeUintLE=c.prototype.writeUIntLE=function(e,r,u,f){if(e=+e,r=r>>>0,u=u>>>0,!f){const F=Math.pow(2,8*u)-1;O(this,e,r,u,F,0)}let d=1,g=0;for(this[r]=e&255;++g<u&&(d*=256);)this[r+g]=e/d&255;return r+u},c.prototype.writeUintBE=c.prototype.writeUIntBE=function(e,r,u,f){if(e=+e,r=r>>>0,u=u>>>0,!f){const F=Math.pow(2,8*u)-1;O(this,e,r,u,F,0)}let d=u-1,g=1;for(this[r+d]=e&255;--d>=0&&(g*=256);)this[r+d]=e/g&255;return r+u},c.prototype.writeUint8=c.prototype.writeUInt8=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,1,255,0),this[r]=e&255,r+1},c.prototype.writeUint16LE=c.prototype.writeUInt16LE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,2,65535,0),this[r]=e&255,this[r+1]=e>>>8,r+2},c.prototype.writeUint16BE=c.prototype.writeUInt16BE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,2,65535,0),this[r]=e>>>8,this[r+1]=e&255,r+2},c.prototype.writeUint32LE=c.prototype.writeUInt32LE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,4,4294967295,0),this[r+3]=e>>>24,this[r+2]=e>>>16,this[r+1]=e>>>8,this[r]=e&255,r+4},c.prototype.writeUint32BE=c.prototype.writeUInt32BE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,4,4294967295,0),this[r]=e>>>24,this[r+1]=e>>>16,this[r+2]=e>>>8,this[r+3]=e&255,r+4};function et(o,e,r,u,f){Ct(e,u,f,o,r,7);let d=Number(e&BigInt(4294967295));o[r++]=d,d=d>>8,o[r++]=d,d=d>>8,o[r++]=d,d=d>>8,o[r++]=d;let g=Number(e>>BigInt(32)&BigInt(4294967295));return o[r++]=g,g=g>>8,o[r++]=g,g=g>>8,o[r++]=g,g=g>>8,o[r++]=g,r}function rt(o,e,r,u,f){Ct(e,u,f,o,r,7);let d=Number(e&BigInt(4294967295));o[r+7]=d,d=d>>8,o[r+6]=d,d=d>>8,o[r+5]=d,d=d>>8,o[r+4]=d;let g=Number(e>>BigInt(32)&BigInt(4294967295));return o[r+3]=g,g=g>>8,o[r+2]=g,g=g>>8,o[r+1]=g,g=g>>8,o[r]=g,r+8}c.prototype.writeBigUInt64LE=Lt(function(e,r=0){return et(this,e,r,BigInt(0),BigInt("0xffffffffffffffff"))}),c.prototype.writeBigUInt64BE=Lt(function(e,r=0){return rt(this,e,r,BigInt(0),BigInt("0xffffffffffffffff"))}),c.prototype.writeIntLE=function(e,r,u,f){if(e=+e,r=r>>>0,!f){const J=Math.pow(2,8*u-1);O(this,e,r,u,J-1,-J)}let d=0,g=1,F=0;for(this[r]=e&255;++d<u&&(g*=256);)e<0&&F===0&&this[r+d-1]!==0&&(F=1),this[r+d]=(e/g>>0)-F&255;return r+u},c.prototype.writeIntBE=function(e,r,u,f){if(e=+e,r=r>>>0,!f){const J=Math.pow(2,8*u-1);O(this,e,r,u,J-1,-J)}let d=u-1,g=1,F=0;for(this[r+d]=e&255;--d>=0&&(g*=256);)e<0&&F===0&&this[r+d+1]!==0&&(F=1),this[r+d]=(e/g>>0)-F&255;return r+u},c.prototype.writeInt8=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,1,127,-128),e<0&&(e=255+e+1),this[r]=e&255,r+1},c.prototype.writeInt16LE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,2,32767,-32768),this[r]=e&255,this[r+1]=e>>>8,r+2},c.prototype.writeInt16BE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,2,32767,-32768),this[r]=e>>>8,this[r+1]=e&255,r+2},c.prototype.writeInt32LE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,4,2147483647,-2147483648),this[r]=e&255,this[r+1]=e>>>8,this[r+2]=e>>>16,this[r+3]=e>>>24,r+4},c.prototype.writeInt32BE=function(e,r,u){return e=+e,r=r>>>0,u||O(this,e,r,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[r]=e>>>24,this[r+1]=e>>>16,this[r+2]=e>>>8,this[r+3]=e&255,r+4},c.prototype.writeBigInt64LE=Lt(function(e,r=0){return et(this,e,r,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),c.prototype.writeBigInt64BE=Lt(function(e,r=0){return rt(this,e,r,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function ht(o,e,r,u,f,d){if(r+u>o.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function ot(o,e,r,u,f){return e=+e,r=r>>>0,f||ht(o,e,r,4),n.write(o,e,r,u,23,4),r+4}c.prototype.writeFloatLE=function(e,r,u){return ot(this,e,r,!0,u)},c.prototype.writeFloatBE=function(e,r,u){return ot(this,e,r,!1,u)};function ut(o,e,r,u,f){return e=+e,r=r>>>0,f||ht(o,e,r,8),n.write(o,e,r,u,52,8),r+8}c.prototype.writeDoubleLE=function(e,r,u){return ut(this,e,r,!0,u)},c.prototype.writeDoubleBE=function(e,r,u){return ut(this,e,r,!1,u)},c.prototype.copy=function(e,r,u,f){if(!c.isBuffer(e))throw new TypeError("argument should be a Buffer");if(u||(u=0),!f&&f!==0&&(f=this.length),r>=e.length&&(r=e.length),r||(r=0),f>0&&f<u&&(f=u),f===u||e.length===0||this.length===0)return 0;if(r<0)throw new RangeError("targetStart out of bounds");if(u<0||u>=this.length)throw new RangeError("Index out of range");if(f<0)throw new RangeError("sourceEnd out of bounds");f>this.length&&(f=this.length),e.length-r<f-u&&(f=e.length-r+u);const d=f-u;return this===e&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(r,u,f):Uint8Array.prototype.set.call(e,this.subarray(u,f),r),d},c.prototype.fill=function(e,r,u,f){if(typeof e=="string"){if(typeof r=="string"?(f=r,r=0,u=this.length):typeof u=="string"&&(f=u,u=this.length),f!==void 0&&typeof f!="string")throw new TypeError("encoding must be a string");if(typeof f=="string"&&!c.isEncoding(f))throw new TypeError("Unknown encoding: "+f);if(e.length===1){const g=e.charCodeAt(0);(f==="utf8"&&g<128||f==="latin1")&&(e=g)}}else typeof e=="number"?e=e&255:typeof e=="boolean"&&(e=Number(e));if(r<0||this.length<r||this.length<u)throw new RangeError("Out of range index");if(u<=r)return this;r=r>>>0,u=u===void 0?this.length:u>>>0,e||(e=0);let d;if(typeof e=="number")for(d=r;d<u;++d)this[d]=e;else{const g=c.isBuffer(e)?e:c.from(e,f),F=g.length;if(F===0)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(d=0;d<u-r;++d)this[d+r]=g[d%F]}return this};const dt={};function wt(o,e,r){dt[o]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:e.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${o}]`,this.stack,delete this.name}get code(){return o}set code(f){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:f,writable:!0})}toString(){return`${this.name} [${o}]: ${this.message}`}}}wt("ERR_BUFFER_OUT_OF_BOUNDS",function(o){return o?`${o} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),wt("ERR_INVALID_ARG_TYPE",function(o,e){return`The "${o}" argument must be of type number. Received type ${typeof e}`},TypeError),wt("ERR_OUT_OF_RANGE",function(o,e,r){let u=`The value of "${o}" is out of range.`,f=r;return Number.isInteger(r)&&Math.abs(r)>2**32?f=It(String(r)):typeof r=="bigint"&&(f=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(f=It(f)),f+="n"),u+=` It must be ${e}. Received ${f}`,u},RangeError);function It(o){let e="",r=o.length;const u=o[0]==="-"?1:0;for(;r>=u+4;r-=3)e=`_${o.slice(r-3,r)}${e}`;return`${o.slice(0,r)}${e}`}function Ut(o,e,r){ft(e,"offset"),(o[e]===void 0||o[e+r]===void 0)&&xt(e,o.length-(r+1))}function Ct(o,e,r,u,f,d){if(o>r||o<e){const g=typeof e=="bigint"?"n":"";let F;throw d>3?e===0||e===BigInt(0)?F=`>= 0${g} and < 2${g} ** ${(d+1)*8}${g}`:F=`>= -(2${g} ** ${(d+1)*8-1}${g}) and < 2 ** ${(d+1)*8-1}${g}`:F=`>= ${e}${g} and <= ${r}${g}`,new dt.ERR_OUT_OF_RANGE("value",F,o)}Ut(u,f,d)}function ft(o,e){if(typeof o!="number")throw new dt.ERR_INVALID_ARG_TYPE(e,"number",o)}function xt(o,e,r){throw Math.floor(o)!==o?(ft(o,r),new dt.ERR_OUT_OF_RANGE(r||"offset","an integer",o)):e<0?new dt.ERR_BUFFER_OUT_OF_BOUNDS:new dt.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${e}`,o)}const Jt=/[^+/0-9A-Za-z-_]/g;function se(o){if(o=o.split("=")[0],o=o.trim().replace(Jt,""),o.length<2)return"";for(;o.length%4!==0;)o=o+"=";return o}function ne(o,e){e=e||1/0;let r;const u=o.length;let f=null;const d=[];for(let g=0;g<u;++g){if(r=o.charCodeAt(g),r>55295&&r<57344){if(!f){if(r>56319){(e-=3)>-1&&d.push(239,191,189);continue}else if(g+1===u){(e-=3)>-1&&d.push(239,191,189);continue}f=r;continue}if(r<56320){(e-=3)>-1&&d.push(239,191,189),f=r;continue}r=(f-55296<<10|r-56320)+65536}else f&&(e-=3)>-1&&d.push(239,191,189);if(f=null,r<128){if((e-=1)<0)break;d.push(r)}else if(r<2048){if((e-=2)<0)break;d.push(r>>6|192,r&63|128)}else if(r<65536){if((e-=3)<0)break;d.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((e-=4)<0)break;d.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return d}function qe(o){const e=[];for(let r=0;r<o.length;++r)e.push(o.charCodeAt(r)&255);return e}function De(o,e){let r,u,f;const d=[];for(let g=0;g<o.length&&!((e-=2)<0);++g)r=o.charCodeAt(g),u=r>>8,f=r%256,d.push(f),d.push(u);return d}function fe(o){return t.toByteArray(se(o))}function Qt(o,e,r,u){let f;for(f=0;f<u&&!(f+r>=e.length||f>=o.length);++f)e[f+r]=o[f];return f}function bt(o,e){return o instanceof e||o!=null&&o.constructor!=null&&o.constructor.name!=null&&o.constructor.name===e.name}function re(o){return o!==o}const de=function(){const o="0123456789abcdef",e=new Array(256);for(let r=0;r<16;++r){const u=r*16;for(let f=0;f<16;++f)e[u+f]=o[r]+o[f]}return e}();function Lt(o){return typeof BigInt>"u"?xe:o}function xe(){throw new Error("BigInt not supported")}})(_r);Object.defineProperty(B,"__esModule",{value:!0});B.s16=B.s8=B.nu64be=B.u48be=B.u40be=B.u32be=B.u24be=B.u16be=Dt=B.nu64=B.u48=B.u40=V=B.u32=B.u24=jt=B.u16=yt=B.u8=we=B.offset=B.greedy=B.Constant=B.UTF8=B.CString=B.Blob=B.Boolean=B.BitField=B.BitStructure=B.VariantLayout=B.Union=B.UnionLayoutDiscriminator=B.UnionDiscriminator=B.Structure=B.Sequence=B.DoubleBE=B.Double=B.FloatBE=B.Float=B.NearInt64BE=B.NearInt64=B.NearUInt64BE=B.NearUInt64=B.IntBE=B.Int=B.UIntBE=B.UInt=B.OffsetLayout=B.GreedyCount=B.ExternalLayout=B.bindConstructorLayout=B.nameWithProperty=B.Layout=B.uint8ArrayToBuffer=B.checkUint8Array=void 0;B.constant=B.utf8=B.cstr=Rt=B.blob=B.unionLayoutDiscriminator=B.union=zt=B.seq=B.bits=W=B.struct=B.f64be=B.f64=B.f32be=B.f32=B.ns64be=B.s48be=B.s40be=B.s32be=B.s24be=B.s16be=Ht=B.ns64=B.s48=B.s40=B.s32=B.s24=void 0;const Pn=_r;function Pe(a){if(!(a instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}B.checkUint8Array=Pe;function pt(a){return Pe(a),Pn.Buffer.from(a.buffer,a.byteOffset,a.length)}B.uint8ArrayToBuffer=pt;class mt{constructor(t,n){if(!Number.isInteger(t))throw new TypeError("span must be an integer");this.span=t,this.property=n}makeDestinationObject(){return{}}getSpan(t,n){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(t){const n=Object.create(this.constructor.prototype);return Object.assign(n,this),n.property=t,n}fromArray(t){}}B.Layout=mt;function On(a,t){return t.property?a+"["+t.property+"]":a}B.nameWithProperty=On;function to(a,t){if(typeof a!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(a,"layout_"))throw new Error("Class is already bound to a layout");if(!(t&&t instanceof mt))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(t,"boundConstructor_"))throw new Error("layout is already bound to a constructor");a.layout_=t,t.boundConstructor_=a,t.makeDestinationObject=()=>new a,Object.defineProperty(a.prototype,"encode",{value(n,i){return t.encode(this,n,i)},writable:!0}),Object.defineProperty(a,"decode",{value(n,i){return t.decode(n,i)},writable:!0})}B.bindConstructorLayout=to;class Mt extends mt{isCount(){throw new Error("ExternalLayout is abstract")}}B.ExternalLayout=Mt;class Tr extends Mt{constructor(t=1,n){if(!Number.isInteger(t)||0>=t)throw new TypeError("elementSpan must be a (positive) integer");super(-1,n),this.elementSpan=t}isCount(){return!0}decode(t,n=0){Pe(t);const i=t.length-n;return Math.floor(i/this.elementSpan)}encode(t,n,i){return 0}}B.GreedyCount=Tr;class vn extends Mt{constructor(t,n=0,i){if(!(t instanceof mt))throw new TypeError("layout must be a Layout");if(!Number.isInteger(n))throw new TypeError("offset must be integer or undefined");super(t.span,i||t.property),this.layout=t,this.offset=n}isCount(){return this.layout instanceof Xt||this.layout instanceof ee}decode(t,n=0){return this.layout.decode(t,n+this.offset)}encode(t,n,i=0){return this.layout.encode(t,n,i+this.offset)}}B.OffsetLayout=vn;class Xt extends mt{constructor(t,n){if(super(t,n),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,n=0){return pt(t).readUIntLE(n,this.span)}encode(t,n,i=0){return pt(n).writeUIntLE(t,i,this.span),this.span}}B.UInt=Xt;class ee extends mt{constructor(t,n){if(super(t,n),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,n=0){return pt(t).readUIntBE(n,this.span)}encode(t,n,i=0){return pt(n).writeUIntBE(t,i,this.span),this.span}}B.UIntBE=ee;class Be extends mt{constructor(t,n){if(super(t,n),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,n=0){return pt(t).readIntLE(n,this.span)}encode(t,n,i=0){return pt(n).writeIntLE(t,i,this.span),this.span}}B.Int=Be;class Oe extends mt{constructor(t,n){if(super(t,n),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,n=0){return pt(t).readIntBE(n,this.span)}encode(t,n,i=0){return pt(n).writeIntBE(t,i,this.span),this.span}}B.IntBE=Oe;const bn=Math.pow(2,32);function on(a){const t=Math.floor(a/bn),n=a-t*bn;return{hi32:t,lo32:n}}function sn(a,t){return a*bn+t}class Ur extends mt{constructor(t){super(8,t)}decode(t,n=0){const i=pt(t),s=i.readUInt32LE(n),l=i.readUInt32LE(n+4);return sn(l,s)}encode(t,n,i=0){const s=on(t),l=pt(n);return l.writeUInt32LE(s.lo32,i),l.writeUInt32LE(s.hi32,i+4),8}}B.NearUInt64=Ur;class Cr extends mt{constructor(t){super(8,t)}decode(t,n=0){const i=pt(t),s=i.readUInt32BE(n),l=i.readUInt32BE(n+4);return sn(s,l)}encode(t,n,i=0){const s=on(t),l=pt(n);return l.writeUInt32BE(s.hi32,i),l.writeUInt32BE(s.lo32,i+4),8}}B.NearUInt64BE=Cr;class Lr extends mt{constructor(t){super(8,t)}decode(t,n=0){const i=pt(t),s=i.readUInt32LE(n),l=i.readInt32LE(n+4);return sn(l,s)}encode(t,n,i=0){const s=on(t),l=pt(n);return l.writeUInt32LE(s.lo32,i),l.writeInt32LE(s.hi32,i+4),8}}B.NearInt64=Lr;class Fr extends mt{constructor(t){super(8,t)}decode(t,n=0){const i=pt(t),s=i.readInt32BE(n),l=i.readUInt32BE(n+4);return sn(s,l)}encode(t,n,i=0){const s=on(t),l=pt(n);return l.writeInt32BE(s.hi32,i),l.writeUInt32BE(s.lo32,i+4),8}}B.NearInt64BE=Fr;class Nr extends mt{constructor(t){super(4,t)}decode(t,n=0){return pt(t).readFloatLE(n)}encode(t,n,i=0){return pt(n).writeFloatLE(t,i),4}}B.Float=Nr;class Pr extends mt{constructor(t){super(4,t)}decode(t,n=0){return pt(t).readFloatBE(n)}encode(t,n,i=0){return pt(n).writeFloatBE(t,i),4}}B.FloatBE=Pr;class Or extends mt{constructor(t){super(8,t)}decode(t,n=0){return pt(t).readDoubleLE(n)}encode(t,n,i=0){return pt(n).writeDoubleLE(t,i),8}}B.Double=Or;class vr extends mt{constructor(t){super(8,t)}decode(t,n=0){return pt(t).readDoubleBE(n)}encode(t,n,i=0){return pt(n).writeDoubleBE(t,i),8}}B.DoubleBE=vr;class qr extends mt{constructor(t,n,i){if(!(t instanceof mt))throw new TypeError("elementLayout must be a Layout");if(!(n instanceof Mt&&n.isCount()||Number.isInteger(n)&&0<=n))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(n instanceof Mt)&&0<t.span&&(s=n*t.span),super(s,i),this.elementLayout=t,this.count=n}getSpan(t,n=0){if(0<=this.span)return this.span;let i=0,s=this.count;if(s instanceof Mt&&(s=s.decode(t,n)),0<this.elementLayout.span)i=s*this.elementLayout.span;else{let l=0;for(;l<s;)i+=this.elementLayout.getSpan(t,n+i),++l}return i}decode(t,n=0){const i=[];let s=0,l=this.count;for(l instanceof Mt&&(l=l.decode(t,n));s<l;)i.push(this.elementLayout.decode(t,n)),n+=this.elementLayout.getSpan(t,n),s+=1;return i}encode(t,n,i=0){const s=this.elementLayout,l=t.reduce((h,c)=>h+s.encode(c,n,i+h),0);return this.count instanceof Mt&&this.count.encode(t.length,n,i),l}}B.Sequence=qr;class Dr extends mt{constructor(t,n,i){if(!(Array.isArray(t)&&t.reduce((l,h)=>l&&h instanceof mt,!0)))throw new TypeError("fields must be array of Layout instances");typeof n=="boolean"&&i===void 0&&(i=n,n=void 0);for(const l of t)if(0>l.span&&l.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=t.reduce((l,h)=>l+h.getSpan(),0)}catch{}super(s,n),this.fields=t,this.decodePrefixes=!!i}getSpan(t,n=0){if(0<=this.span)return this.span;let i=0;try{i=this.fields.reduce((s,l)=>{const h=l.getSpan(t,n);return n+=h,s+h},0)}catch{throw new RangeError("indeterminate span")}return i}decode(t,n=0){Pe(t);const i=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(i[s.property]=s.decode(t,n)),n+=s.getSpan(t,n),this.decodePrefixes&&t.length===n)break;return i}encode(t,n,i=0){const s=i;let l=0,h=0;for(const c of this.fields){let p=c.span;if(h=0<p?p:0,c.property!==void 0){const w=t[c.property];w!==void 0&&(h=c.encode(w,n,i),0>p&&(p=c.getSpan(n,i)))}l=i,i+=p}return l+h-s}fromArray(t){const n=this.makeDestinationObject();for(const i of this.fields)i.property!==void 0&&0<t.length&&(n[i.property]=t.shift());return n}layoutFor(t){if(typeof t!="string")throw new TypeError("property must be string");for(const n of this.fields)if(n.property===t)return n}offsetOf(t){if(typeof t!="string")throw new TypeError("property must be string");let n=0;for(const i of this.fields){if(i.property===t)return n;0>i.span?n=-1:0<=n&&(n+=i.span)}}}B.Structure=Dr;class qn{constructor(t){this.property=t}decode(t,n){throw new Error("UnionDiscriminator is abstract")}encode(t,n,i){throw new Error("UnionDiscriminator is abstract")}}B.UnionDiscriminator=qn;class Je extends qn{constructor(t,n){if(!(t instanceof Mt&&t.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(n||t.property||"variant"),this.layout=t}decode(t,n){return this.layout.decode(t,n)}encode(t,n,i){return this.layout.encode(t,n,i)}}B.UnionLayoutDiscriminator=Je;class Dn extends mt{constructor(t,n,i){let s;if(t instanceof Xt||t instanceof ee)s=new Je(new vn(t));else if(t instanceof Mt&&t.isCount())s=new Je(t);else if(t instanceof qn)s=t;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(n===void 0&&(n=null),!(n===null||n instanceof mt))throw new TypeError("defaultLayout must be null or a Layout");if(n!==null){if(0>n.span)throw new Error("defaultLayout must have constant span");n.property===void 0&&(n=n.replicate("content"))}let l=-1;n&&(l=n.span,0<=l&&(t instanceof Xt||t instanceof ee)&&(l+=s.layout.span)),super(l,i),this.discriminator=s,this.usesPrefixDiscriminator=t instanceof Xt||t instanceof ee,this.defaultLayout=n,this.registry={};let h=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(c){return h(c)},this.configGetSourceVariant=function(c){h=c.bind(this)}}getSpan(t,n=0){if(0<=this.span)return this.span;const i=this.getVariant(t,n);if(!i)throw new Error("unable to determine span for unrecognized variant");return i.getSpan(t,n)}defaultGetSourceVariant(t){if(Object.prototype.hasOwnProperty.call(t,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(t,this.defaultLayout.property))return;const n=this.registry[t[this.discriminator.property]];if(n&&(!n.layout||n.property&&Object.prototype.hasOwnProperty.call(t,n.property)))return n}else for(const n in this.registry){const i=this.registry[n];if(i.property&&Object.prototype.hasOwnProperty.call(t,i.property))return i}throw new Error("unable to infer src variant")}decode(t,n=0){let i;const s=this.discriminator,l=s.decode(t,n),h=this.registry[l];if(h===void 0){const c=this.defaultLayout;let p=0;this.usesPrefixDiscriminator&&(p=s.layout.span),i=this.makeDestinationObject(),i[s.property]=l,i[c.property]=c.decode(t,n+p)}else i=h.decode(t,n);return i}encode(t,n,i=0){const s=this.getSourceVariant(t);if(s===void 0){const l=this.discriminator,h=this.defaultLayout;let c=0;return this.usesPrefixDiscriminator&&(c=l.layout.span),l.encode(t[l.property],n,i),c+h.encode(t[h.property],n,i+c)}return s.encode(t,n,i)}addVariant(t,n,i){const s=new Kr(this,t,n,i);return this.registry[t]=s,s}getVariant(t,n=0){let i;return t instanceof Uint8Array?i=this.discriminator.decode(t,n):i=t,this.registry[i]}}B.Union=Dn;class Kr extends mt{constructor(t,n,i,s){if(!(t instanceof Dn))throw new TypeError("union must be a Union");if(!Number.isInteger(n)||0>n)throw new TypeError("variant must be a (non-negative) integer");if(typeof i=="string"&&s===void 0&&(s=i,i=null),i){if(!(i instanceof mt))throw new TypeError("layout must be a Layout");if(t.defaultLayout!==null&&0<=i.span&&i.span>t.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let l=t.span;0>t.span&&(l=i?i.span:0,0<=l&&t.usesPrefixDiscriminator&&(l+=t.discriminator.layout.span)),super(l,s),this.union=t,this.variant=n,this.layout=i||null}getSpan(t,n=0){if(0<=this.span)return this.span;let i=0;this.union.usesPrefixDiscriminator&&(i=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(t,n+i)),i+s}decode(t,n=0){const i=this.makeDestinationObject();if(this!==this.union.getVariant(t,n))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?i[this.property]=this.layout.decode(t,n+s):this.property?i[this.property]=!0:this.union.usesPrefixDiscriminator&&(i[this.union.discriminator.property]=this.variant),i}encode(t,n,i=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(t,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,n,i);let l=s;if(this.layout&&(this.layout.encode(t[this.property],n,i+s),l+=this.layout.getSpan(n,i+s),0<=this.union.span&&l>this.union.span))throw new Error("encoded variant overruns containing union");return l}fromArray(t){if(this.layout)return this.layout.fromArray(t)}}B.VariantLayout=Kr;function Se(a){return 0>a&&(a+=4294967296),a}class Kn extends mt{constructor(t,n,i){if(!(t instanceof Xt||t instanceof ee))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof n=="string"&&i===void 0&&(i=n,n=!1),4<t.span)throw new RangeError("word cannot exceed 32 bits");super(t.span,i),this.word=t,this.msb=!!n,this.fields=[];let s=0;this._packedSetValue=function(l){return s=Se(l),this},this._packedGetValue=function(){return s}}decode(t,n=0){const i=this.makeDestinationObject(),s=this.word.decode(t,n);this._packedSetValue(s);for(const l of this.fields)l.property!==void 0&&(i[l.property]=l.decode(t));return i}encode(t,n,i=0){const s=this.word.decode(n,i);this._packedSetValue(s);for(const l of this.fields)if(l.property!==void 0){const h=t[l.property];h!==void 0&&l.encode(h)}return this.word.encode(this._packedGetValue(),n,i)}addField(t,n){const i=new $n(this,t,n);return this.fields.push(i),i}addBoolean(t){const n=new $r(this,t);return this.fields.push(n),n}fieldFor(t){if(typeof t!="string")throw new TypeError("property must be string");for(const n of this.fields)if(n.property===t)return n}}B.BitStructure=Kn;class $n{constructor(t,n,i){if(!(t instanceof Kn))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(n)||0>=n)throw new TypeError("bits must be positive integer");const s=8*t.span,l=t.fields.reduce((h,c)=>h+c.bits,0);if(n+l>s)throw new Error("bits too long for span remainder ("+(s-l)+" of "+s+" remain)");this.container=t,this.bits=n,this.valueMask=(1<<n)-1,n===32&&(this.valueMask=4294967295),this.start=l,this.container.msb&&(this.start=s-l-n),this.wordMask=Se(this.valueMask<<this.start),this.property=i}decode(t,n){const i=this.container._packedGetValue();return Se(i&this.wordMask)>>>this.start}encode(t){if(typeof t!="number"||!Number.isInteger(t)||t!==Se(t&this.valueMask))throw new TypeError(On("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const n=this.container._packedGetValue(),i=Se(t<<this.start);this.container._packedSetValue(Se(n&~this.wordMask)|i)}}B.BitField=$n;class $r extends $n{constructor(t,n){super(t,1,n)}decode(t,n){return!!super.decode(t,n)}encode(t){typeof t=="boolean"&&(t=+t),super.encode(t)}}B.Boolean=$r;class zr extends mt{constructor(t,n){if(!(t instanceof Mt&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let i=-1;t instanceof Mt||(i=t),super(i,n),this.length=t}getSpan(t,n){let i=this.span;return 0>i&&(i=this.length.decode(t,n)),i}decode(t,n=0){let i=this.span;return 0>i&&(i=this.length.decode(t,n)),pt(t).slice(n,n+i)}encode(t,n,i){let s=this.length;if(this.length instanceof Mt&&(s=t.length),!(t instanceof Uint8Array&&s===t.length))throw new TypeError(On("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(i+s>n.length)throw new RangeError("encoding overruns Uint8Array");const l=pt(t);return pt(n).write(l.toString("hex"),i,s,"hex"),this.length instanceof Mt&&this.length.encode(s,n,i),s}}B.Blob=zr;class Mr extends mt{constructor(t){super(-1,t)}getSpan(t,n=0){Pe(t);let i=n;for(;i<t.length&&t[i]!==0;)i+=1;return 1+i-n}decode(t,n=0){const i=this.getSpan(t,n);return pt(t).slice(n,n+i-1).toString("utf-8")}encode(t,n,i=0){typeof t!="string"&&(t=String(t));const s=Pn.Buffer.from(t,"utf8"),l=s.length;if(i+l>n.length)throw new RangeError("encoding overruns Buffer");const h=pt(n);return s.copy(h,i),h[i+l]=0,l+1}}B.CString=Mr;class Wr extends mt{constructor(t,n){if(typeof t=="string"&&n===void 0&&(n=t,t=void 0),t===void 0)t=-1;else if(!Number.isInteger(t))throw new TypeError("maxSpan must be an integer");super(-1,n),this.maxSpan=t}getSpan(t,n=0){return Pe(t),t.length-n}decode(t,n=0){const i=this.getSpan(t,n);if(0<=this.maxSpan&&this.maxSpan<i)throw new RangeError("text length exceeds maxSpan");return pt(t).slice(n,n+i).toString("utf-8")}encode(t,n,i=0){typeof t!="string"&&(t=String(t));const s=Pn.Buffer.from(t,"utf8"),l=s.length;if(0<=this.maxSpan&&this.maxSpan<l)throw new RangeError("text length exceeds maxSpan");if(i+l>n.length)throw new RangeError("encoding overruns Buffer");return s.copy(pt(n),i),l}}B.UTF8=Wr;class Gr extends mt{constructor(t,n){super(0,n),this.value=t}decode(t,n){return this.value}encode(t,n,i){return 0}}B.Constant=Gr;B.greedy=(a,t)=>new Tr(a,t);var we=B.offset=(a,t,n)=>new vn(a,t,n),yt=B.u8=a=>new Xt(1,a),jt=B.u16=a=>new Xt(2,a);B.u24=a=>new Xt(3,a);var V=B.u32=a=>new Xt(4,a);B.u40=a=>new Xt(5,a);B.u48=a=>new Xt(6,a);var Dt=B.nu64=a=>new Ur(a);B.u16be=a=>new ee(2,a);B.u24be=a=>new ee(3,a);B.u32be=a=>new ee(4,a);B.u40be=a=>new ee(5,a);B.u48be=a=>new ee(6,a);B.nu64be=a=>new Cr(a);B.s8=a=>new Be(1,a);B.s16=a=>new Be(2,a);B.s24=a=>new Be(3,a);B.s32=a=>new Be(4,a);B.s40=a=>new Be(5,a);B.s48=a=>new Be(6,a);var Ht=B.ns64=a=>new Lr(a);B.s16be=a=>new Oe(2,a);B.s24be=a=>new Oe(3,a);B.s32be=a=>new Oe(4,a);B.s40be=a=>new Oe(5,a);B.s48be=a=>new Oe(6,a);B.ns64be=a=>new Fr(a);B.f32=a=>new Nr(a);B.f32be=a=>new Pr(a);B.f64=a=>new Or(a);B.f64be=a=>new vr(a);var W=B.struct=(a,t,n)=>new Dr(a,t,n);B.bits=(a,t,n)=>new Kn(a,t,n);var zt=B.seq=(a,t,n)=>new qr(a,t,n);B.union=(a,t,n)=>new Dn(a,t,n);B.unionLayoutDiscriminator=(a,t)=>new Je(a,t);var Rt=B.blob=(a,t)=>new zr(a,t);B.cstr=a=>new Mr(a);B.utf8=(a,t)=>new Wr(a,t);B.constant=(a,t)=>new Gr(a,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function eo(a){const t=Cn(a);Fe(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:i,a:s}=t;if(n){if(!i.eql(s,i.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:no,hexToBytes:ro}=Ui,ge={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(a){const{Err:t}=ge;if(a.length<2||a[0]!==2)throw new t("Invalid signature integer tag");const n=a[1],i=a.subarray(2,n+2);if(!n||i.length!==n)throw new t("Invalid signature integer: wrong length");if(i[0]&128)throw new t("Invalid signature integer: negative");if(i[0]===0&&!(i[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:no(i),l:a.subarray(n+2)}},toSig(a){const{Err:t}=ge,n=typeof a=="string"?ro(a):a;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let i=n.length;if(i<2||n[0]!=48)throw new t("Invalid signature tag");if(n[1]!==i-2)throw new t("Invalid signature: incorrect length");const{d:s,l}=ge._parseInt(n.subarray(2)),{d:h,l:c}=ge._parseInt(l);if(c.length)throw new t("Invalid signature: left bytes after parsing");return{r:s,s:h}},hexFromSig(a){const t=w=>Number.parseInt(w[0],16)&8?"00"+w:w,n=w=>{const m=w.toString(16);return m.length&1?`0${m}`:m},i=t(n(a.s)),s=t(n(a.r)),l=i.length/2,h=s.length/2,c=n(l),p=n(h);return`30${n(h+l+4)}02${p}${s}02${c}${i}`}},ce=BigInt(0),Vt=BigInt(1);BigInt(2);const tr=BigInt(3);BigInt(4);function io(a){const t=eo(a),{Fp:n}=t,i=t.toBytes||((x,y,E)=>{const A=y.toAffine();return be(Uint8Array.from([4]),n.toBytes(A.x),n.toBytes(A.y))}),s=t.fromBytes||(x=>{const y=x.subarray(1),E=n.fromBytes(y.subarray(0,n.BYTES)),A=n.fromBytes(y.subarray(n.BYTES,2*n.BYTES));return{x:E,y:A}});function l(x){const{a:y,b:E}=t,A=n.sqr(x),K=n.mul(A,x);return n.add(n.add(K,n.mul(x,y)),E)}if(!n.eql(n.sqr(t.Gy),l(t.Gx)))throw new Error("bad generator point: equation left != right");function h(x){return typeof x=="bigint"&&ce<x&&x<t.n}function c(x){if(!h(x))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function p(x){const{allowedPrivateKeyLengths:y,nByteLength:E,wrapPrivateKey:A,n:K}=t;if(y&&typeof x!="bigint"){if(x instanceof Uint8Array&&(x=me(x)),typeof x!="string"||!y.includes(x.length))throw new Error("Invalid key");x=x.padStart(E*2,"0")}let G;try{G=typeof x=="bigint"?x:ye(vt("private key",x,E))}catch{throw new Error(`private key must be ${E} bytes, hex or bigint, not ${typeof x}`)}return A&&(G=Et(G,K)),c(G),G}const w=new Map;function m(x){if(!(x instanceof I))throw new Error("ProjectivePoint expected")}class I{constructor(y,E,A){if(this.px=y,this.py=E,this.pz=A,y==null||!n.isValid(y))throw new Error("x required");if(E==null||!n.isValid(E))throw new Error("y required");if(A==null||!n.isValid(A))throw new Error("z required")}static fromAffine(y){const{x:E,y:A}=y||{};if(!y||!n.isValid(E)||!n.isValid(A))throw new Error("invalid affine point");if(y instanceof I)throw new Error("projective point not allowed");const K=G=>n.eql(G,n.ZERO);return K(E)&&K(A)?I.ZERO:new I(E,A,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(y){const E=n.invertBatch(y.map(A=>A.pz));return y.map((A,K)=>A.toAffine(E[K])).map(I.fromAffine)}static fromHex(y){const E=I.fromAffine(s(vt("pointHex",y)));return E.assertValidity(),E}static fromPrivateKey(y){return I.BASE.multiply(p(y))}_setWindowSize(y){this._WINDOW_SIZE=y,w.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:y,y:E}=this.toAffine();if(!n.isValid(y)||!n.isValid(E))throw new Error("bad point: x or y not FE");const A=n.sqr(E),K=l(y);if(!n.eql(A,K))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y}=this.toAffine();if(n.isOdd)return!n.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(y){m(y);const{px:E,py:A,pz:K}=this,{px:G,py:it,pz:P}=y,z=n.eql(n.mul(E,P),n.mul(G,K)),j=n.eql(n.mul(A,P),n.mul(it,K));return z&&j}negate(){return new I(this.px,n.neg(this.py),this.pz)}double(){const{a:y,b:E}=t,A=n.mul(E,tr),{px:K,py:G,pz:it}=this;let P=n.ZERO,z=n.ZERO,j=n.ZERO,tt=n.mul(K,K),Pt=n.mul(G,G),gt=n.mul(it,it),at=n.mul(K,G);return at=n.add(at,at),j=n.mul(K,it),j=n.add(j,j),P=n.mul(y,j),z=n.mul(A,gt),z=n.add(P,z),P=n.sub(Pt,z),z=n.add(Pt,z),z=n.mul(P,z),P=n.mul(at,P),j=n.mul(A,j),gt=n.mul(y,gt),at=n.sub(tt,gt),at=n.mul(y,at),at=n.add(at,j),j=n.add(tt,tt),tt=n.add(j,tt),tt=n.add(tt,gt),tt=n.mul(tt,at),z=n.add(z,tt),gt=n.mul(G,it),gt=n.add(gt,gt),tt=n.mul(gt,at),P=n.sub(P,tt),j=n.mul(gt,Pt),j=n.add(j,j),j=n.add(j,j),new I(P,z,j)}add(y){m(y);const{px:E,py:A,pz:K}=this,{px:G,py:it,pz:P}=y;let z=n.ZERO,j=n.ZERO,tt=n.ZERO;const Pt=t.a,gt=n.mul(t.b,tr);let at=n.mul(E,G),Ot=n.mul(A,it),Tt=n.mul(K,P),$t=n.add(E,A),U=n.add(G,it);$t=n.mul($t,U),U=n.add(at,Ot),$t=n.sub($t,U),U=n.add(E,K);let $=n.add(G,P);return U=n.mul(U,$),$=n.add(at,Tt),U=n.sub(U,$),$=n.add(A,K),z=n.add(it,P),$=n.mul($,z),z=n.add(Ot,Tt),$=n.sub($,z),tt=n.mul(Pt,U),z=n.mul(gt,Tt),tt=n.add(z,tt),z=n.sub(Ot,tt),tt=n.add(Ot,tt),j=n.mul(z,tt),Ot=n.add(at,at),Ot=n.add(Ot,at),Tt=n.mul(Pt,Tt),U=n.mul(gt,U),Ot=n.add(Ot,Tt),Tt=n.sub(at,Tt),Tt=n.mul(Pt,Tt),U=n.add(U,Tt),at=n.mul(Ot,U),j=n.add(j,at),at=n.mul($,U),z=n.mul($t,z),z=n.sub(z,at),at=n.mul($t,Ot),tt=n.mul($,tt),tt=n.add(tt,at),new I(z,j,tt)}subtract(y){return this.add(y.negate())}is0(){return this.equals(I.ZERO)}wNAF(y){return R.wNAFCached(this,w,y,E=>{const A=n.invertBatch(E.map(K=>K.pz));return E.map((K,G)=>K.toAffine(A[G])).map(I.fromAffine)})}multiplyUnsafe(y){const E=I.ZERO;if(y===ce)return E;if(c(y),y===Vt)return this;const{endo:A}=t;if(!A)return R.unsafeLadder(this,y);let{k1neg:K,k1:G,k2neg:it,k2:P}=A.splitScalar(y),z=E,j=E,tt=this;for(;G>ce||P>ce;)G&Vt&&(z=z.add(tt)),P&Vt&&(j=j.add(tt)),tt=tt.double(),G>>=Vt,P>>=Vt;return K&&(z=z.negate()),it&&(j=j.negate()),j=new I(n.mul(j.px,A.beta),j.py,j.pz),z.add(j)}multiply(y){c(y);let E=y,A,K;const{endo:G}=t;if(G){const{k1neg:it,k1:P,k2neg:z,k2:j}=G.splitScalar(E);let{p:tt,f:Pt}=this.wNAF(P),{p:gt,f:at}=this.wNAF(j);tt=R.constTimeNegate(it,tt),gt=R.constTimeNegate(z,gt),gt=new I(n.mul(gt.px,G.beta),gt.py,gt.pz),A=tt.add(gt),K=Pt.add(at)}else{const{p:it,f:P}=this.wNAF(E);A=it,K=P}return I.normalizeZ([A,K])[0]}multiplyAndAddUnsafe(y,E,A){const K=I.BASE,G=(P,z)=>z===ce||z===Vt||!P.equals(K)?P.multiplyUnsafe(z):P.multiply(z),it=G(this,E).add(G(y,A));return it.is0()?void 0:it}toAffine(y){const{px:E,py:A,pz:K}=this,G=this.is0();y==null&&(y=G?n.ONE:n.inv(K));const it=n.mul(E,y),P=n.mul(A,y),z=n.mul(K,y);if(G)return{x:n.ZERO,y:n.ZERO};if(!n.eql(z,n.ONE))throw new Error("invZ was invalid");return{x:it,y:P}}isTorsionFree(){const{h:y,isTorsionFree:E}=t;if(y===Vt)return!0;if(E)return E(I,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:y,clearCofactor:E}=t;return y===Vt?this:E?E(I,this):this.multiplyUnsafe(t.h)}toRawBytes(y=!0){return this.assertValidity(),i(I,this,y)}toHex(y=!0){return me(this.toRawBytes(y))}}I.BASE=new I(t.Gx,t.Gy,n.ONE),I.ZERO=new I(n.ZERO,n.ONE,n.ZERO);const N=t.nBitLength,R=kr(I,t.endo?Math.ceil(N/2):N);return{CURVE:t,ProjectivePoint:I,normPrivateKeyToScalar:p,weierstrassEquation:l,isWithinCurveOrder:h}}function oo(a){const t=Cn(a);return Fe(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function so(a){const t=oo(a),{Fp:n,n:i}=t,s=n.BYTES+1,l=2*n.BYTES+1;function h(U){return ce<U&&U<n.ORDER}function c(U){return Et(U,i)}function p(U){return wn(U,i)}const{ProjectivePoint:w,normPrivateKeyToScalar:m,weierstrassEquation:I,isWithinCurveOrder:N}=io({...t,toBytes(U,$,nt){const C=$.toAffine(),S=n.toBytes(C.x),D=be;return nt?D(Uint8Array.from([$.hasEvenY()?2:3]),S):D(Uint8Array.from([4]),S,n.toBytes(C.y))},fromBytes(U){const $=U.length,nt=U[0],C=U.subarray(1);if($===s&&(nt===2||nt===3)){const S=ye(C);if(!h(S))throw new Error("Point is not on curve");const D=I(S);let _=n.sqrt(D);const O=(_&Vt)===Vt;return(nt&1)===1!==O&&(_=n.neg(_)),{x:S,y:_}}else if($===l&&nt===4){const S=n.fromBytes(C.subarray(0,n.BYTES)),D=n.fromBytes(C.subarray(n.BYTES,2*n.BYTES));return{x:S,y:D}}else throw new Error(`Point of length ${$} was invalid. Expected ${s} compressed bytes or ${l} uncompressed bytes`)}}),R=U=>me(Ue(U,t.nByteLength));function x(U){const $=i>>Vt;return U>$}function y(U){return x(U)?c(-U):U}const E=(U,$,nt)=>ye(U.slice($,nt));class A{constructor($,nt,C){this.r=$,this.s=nt,this.recovery=C,this.assertValidity()}static fromCompact($){const nt=t.nByteLength;return $=vt("compactSignature",$,nt*2),new A(E($,0,nt),E($,nt,2*nt))}static fromDER($){const{r:nt,s:C}=ge.toSig(vt("DER",$));return new A(nt,C)}assertValidity(){if(!N(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!N(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit($){return new A(this.r,this.s,$)}recoverPublicKey($){const{r:nt,s:C,recovery:S}=this,D=j(vt("msgHash",$));if(S==null||![0,1,2,3].includes(S))throw new Error("recovery id invalid");const _=S===2||S===3?nt+t.n:nt;if(_>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const O=S&1?"03":"02",et=w.fromHex(O+R(_)),rt=p(_),ht=c(-D*rt),ot=c(C*rt),ut=w.BASE.multiplyAndAddUnsafe(et,ht,ot);if(!ut)throw new Error("point at infinify");return ut.assertValidity(),ut}hasHighS(){return x(this.s)}normalizeS(){return this.hasHighS()?new A(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Te(this.toDERHex())}toDERHex(){return ge.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Te(this.toCompactHex())}toCompactHex(){return R(this.r)+R(this.s)}}const K={isValidPrivateKey(U){try{return m(U),!0}catch{return!1}},normPrivateKeyToScalar:m,randomPrivateKey:()=>{const U=Ar(t.n);return $i(t.randomBytes(U),t.n)},precompute(U=8,$=w.BASE){return $._setWindowSize(U),$.multiply(BigInt(3)),$}};function G(U,$=!0){return w.fromPrivateKey(U).toRawBytes($)}function it(U){const $=U instanceof Uint8Array,nt=typeof U=="string",C=($||nt)&&U.length;return $?C===s||C===l:nt?C===2*s||C===2*l:U instanceof w}function P(U,$,nt=!0){if(it(U))throw new Error("first arg must be private key");if(!it($))throw new Error("second arg must be public key");return w.fromHex($).multiply(m(U)).toRawBytes(nt)}const z=t.bits2int||function(U){const $=ye(U),nt=U.length*8-t.nBitLength;return nt>0?$>>BigInt(nt):$},j=t.bits2int_modN||function(U){return c(z(U))},tt=Un(t.nBitLength);function Pt(U){if(typeof U!="bigint")throw new Error("bigint expected");if(!(ce<=U&&U<tt))throw new Error(`bigint expected < 2^${t.nBitLength}`);return Ue(U,t.nByteLength)}function gt(U,$,nt=at){if(["recovered","canonical"].some(wt=>wt in nt))throw new Error("sign() legacy options not supported");const{hash:C,randomBytes:S}=t;let{lowS:D,prehash:_,extraEntropy:O}=nt;D==null&&(D=!0),U=vt("msgHash",U),_&&(U=vt("prehashed msgHash",C(U)));const et=j(U),rt=m($),ht=[Pt(rt),Pt(et)];if(O!=null){const wt=O===!0?S(n.BYTES):O;ht.push(vt("extraEntropy",wt))}const ot=be(...ht),ut=et;function dt(wt){const It=z(wt);if(!N(It))return;const Ut=p(It),Ct=w.BASE.multiply(It).toAffine(),ft=c(Ct.x);if(ft===ce)return;const xt=c(Ut*c(ut+ft*rt));if(xt===ce)return;let Jt=(Ct.x===ft?0:2)|Number(Ct.y&Vt),se=xt;return D&&x(xt)&&(se=y(xt),Jt^=1),new A(ft,se,Jt)}return{seed:ot,k2sig:dt}}const at={lowS:t.lowS,prehash:!1},Ot={lowS:t.lowS,prehash:!1};function Tt(U,$,nt=at){const{seed:C,k2sig:S}=gt(U,$,nt),D=t;return Er(D.hash.outputLen,D.nByteLength,D.hmac)(C,S)}w.BASE._setWindowSize(8);function $t(U,$,nt,C=Ot){var Ct;const S=U;if($=vt("msgHash",$),nt=vt("publicKey",nt),"strict"in C)throw new Error("options.strict was renamed to lowS");const{lowS:D,prehash:_}=C;let O,et;try{if(typeof S=="string"||S instanceof Uint8Array)try{O=A.fromDER(S)}catch(ft){if(!(ft instanceof ge.Err))throw ft;O=A.fromCompact(S)}else if(typeof S=="object"&&typeof S.r=="bigint"&&typeof S.s=="bigint"){const{r:ft,s:xt}=S;O=new A(ft,xt)}else throw new Error("PARSE");et=w.fromHex(nt)}catch(ft){if(ft.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(D&&O.hasHighS())return!1;_&&($=t.hash($));const{r:rt,s:ht}=O,ot=j($),ut=p(ht),dt=c(ot*ut),wt=c(rt*ut),It=(Ct=w.BASE.multiplyAndAddUnsafe(et,dt,wt))==null?void 0:Ct.toAffine();return It?c(It.x)===rt:!1}return{CURVE:t,getPublicKey:G,getSharedSecret:P,sign:Tt,verify:$t,ProjectivePoint:w,Signature:A,utils:K}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function co(a){return{hash:a,hmac:(t,...n)=>hi(a,t,Me.concatBytes(...n)),randomBytes:Me.randomBytes}}function ao(a,t){const n=i=>so({...a,...co(i)});return Object.freeze({...n(t),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Hr=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),er=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),uo=BigInt(1),Bn=BigInt(2),nr=(a,t)=>(a+t/Bn)/t;function lo(a){const t=Hr,n=BigInt(3),i=BigInt(6),s=BigInt(11),l=BigInt(22),h=BigInt(23),c=BigInt(44),p=BigInt(88),w=a*a*a%t,m=w*w*a%t,I=kt(m,n,t)*m%t,N=kt(I,n,t)*m%t,R=kt(N,Bn,t)*w%t,x=kt(R,s,t)*R%t,y=kt(x,l,t)*x%t,E=kt(y,c,t)*y%t,A=kt(E,p,t)*E%t,K=kt(A,c,t)*y%t,G=kt(K,n,t)*m%t,it=kt(G,h,t)*x%t,P=kt(it,i,t)*w%t,z=kt(P,Bn,t);if(!En.eql(En.sqr(z),a))throw new Error("Cannot find square root");return z}const En=xr(Hr,void 0,void 0,{sqrt:lo}),zn=ao({a:BigInt(0),b:BigInt(7),Fp:En,n:er,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:a=>{const t=er,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),i=-uo*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),l=n,h=BigInt("0x100000000000000000000000000000000"),c=nr(l*a,t),p=nr(-i*a,t);let w=Et(a-c*n-p*s,t),m=Et(-c*i-p*l,t);const I=w>h,N=m>h;if(I&&(w=t-w),N&&(m=t-m),w>h||m>h)throw new Error("splitScalar: Endomorphism failed, k="+a);return{k1neg:I,k1:w,k2neg:N,k2:m}}}},gn);BigInt(0);zn.ProjectivePoint;Ne.utils.randomPrivateKey;const rr=()=>{const a=Ne.utils.randomPrivateKey(),t=In(a),n=new Uint8Array(64);return n.set(a),n.set(t,32),{publicKey:t,secretKey:n}},In=Ne.getPublicKey;function ir(a){try{return Ne.ExtendedPoint.fromHex(a),!0}catch{return!1}}const ho=(a,t)=>Ne.sign(a,t.slice(0,32)),fo=Ne.verify,Ce=a=>ct.Buffer.isBuffer(a)?a:a instanceof Uint8Array?ct.Buffer.from(a.buffer,a.byteOffset,a.byteLength):ct.Buffer.from(a);class po{constructor(t){Object.assign(this,t)}encode(){return ct.Buffer.from(fi(Ye,this))}static decode(t){return di(Ye,this,t)}static decodeUnchecked(t){return pi(Ye,this,t)}}const Ye=new Map;var Vr;let jr;const go=32,ie=32;function yo(a){return a._bn!==void 0}let or=1;jr=Symbol.toStringTag;class X extends po{constructor(t){if(super({}),this._bn=void 0,yo(t))this._bn=t._bn;else{if(typeof t=="string"){const n=Kt.decode(t);if(n.length!=ie)throw new Error("Invalid public key input");this._bn=new Vn(n)}else this._bn=new Vn(t);if(this._bn.byteLength()>ie)throw new Error("Invalid public key input")}}static unique(){const t=new X(or);return or+=1,new X(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return Kt.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(ct.Buffer);if(t.length===ie)return t;const n=ct.Buffer.alloc(32);return t.copy(n,32-t.length),n}get[jr](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,n,i){const s=ct.Buffer.concat([t.toBuffer(),ct.Buffer.from(n),i.toBuffer()]),l=gn(s);return new X(l)}static createProgramAddressSync(t,n){let i=ct.Buffer.alloc(0);t.forEach(function(l){if(l.length>go)throw new TypeError("Max seed length exceeded");i=ct.Buffer.concat([i,Ce(l)])}),i=ct.Buffer.concat([i,n.toBuffer(),ct.Buffer.from("ProgramDerivedAddress")]);const s=gn(i);if(ir(s))throw new Error("Invalid seeds, address must fall off the curve");return new X(s)}static async createProgramAddress(t,n){return this.createProgramAddressSync(t,n)}static findProgramAddressSync(t,n){let i=255,s;for(;i!=0;){try{const l=t.concat(ct.Buffer.from([i]));s=this.createProgramAddressSync(l,n)}catch(l){if(l instanceof TypeError)throw l;i--;continue}return[s,i]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,n){return this.findProgramAddressSync(t,n)}static isOnCurve(t){const n=new X(t);return ir(n.toBytes())}}Vr=X;X.default=new Vr("11111111111111111111111111111111");Ye.set(X,{kind:"struct",fields:[["_bn","u256"]]});new X("BPFLoader1111111111111111111111111111111111");const _e=1280-40-8,Zr=127,xn=64;class Yr extends Error{constructor(t){super(`Signature ${t} has expired: block height exceeded.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Yr.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Xr extends Error{constructor(t,n){super(`Transaction was not confirmed in ${n.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Xr.prototype,"name",{value:"TransactionExpiredTimeoutError"});class $e extends Error{constructor(t){super(`Signature ${t} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=t}}Object.defineProperty($e.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Qe{constructor(t,n){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=n}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const n of this.keySegments()){if(t<n.length)return n[t];t-=n.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const i=new Map;this.keySegments().flat().forEach((l,h)=>{i.set(l.toBase58(),h)});const s=l=>{const h=i.get(l.toBase58());if(h===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return h};return t.map(l=>({programIdIndex:s(l.programId),accountKeyIndexes:l.keys.map(h=>s(h.pubkey)),data:l.data}))}}const lt=(a="publicKey")=>Rt(32,a),ke=(a="string")=>{const t=W([V("length"),V("lengthPadding"),Rt(we(V(),-8),"chars")],a),n=t.decode.bind(t),i=t.encode.bind(t),s=t;return s.decode=(l,h)=>n(l,h).chars.toString(),s.encode=(l,h,c)=>{const p={chars:ct.Buffer.from(l,"utf8")};return i(p,h,c)},s.alloc=l=>V().span+V().span+ct.Buffer.from(l,"utf8").length,s},wo=(a="authorized")=>W([lt("staker"),lt("withdrawer")],a),mo=(a="lockup")=>W([Ht("unixTimestamp"),Ht("epoch"),lt("custodian")],a),bo=(a="voteInit")=>W([lt("nodePubkey"),lt("authorizedVoter"),lt("authorizedWithdrawer"),yt("commission")],a),Bo=(a="voteAuthorizeWithSeedArgs")=>W([V("voteAuthorizationType"),lt("currentAuthorityDerivedKeyOwnerPubkey"),ke("currentAuthorityDerivedKeySeed"),lt("newAuthorized")],a);function Zt(a){let t=0,n=0;for(;;){let i=a.shift();if(t|=(i&127)<<n*7,n+=1,!(i&128))break}return t}function Yt(a,t){let n=t;for(;;){let i=n&127;if(n>>=7,n==0){a.push(i);break}else i|=128,a.push(i)}}function Ft(a,t){if(!a)throw new Error(t||"Assertion failed")}class cn{constructor(t,n){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=n}static compile(t,n){const i=new Map,s=h=>{const c=h.toBase58();let p=i.get(c);return p===void 0&&(p={isSigner:!1,isWritable:!1,isInvoked:!1},i.set(c,p)),p},l=s(n);l.isSigner=!0,l.isWritable=!0;for(const h of t){s(h.programId).isInvoked=!0;for(const c of h.keys){const p=s(c.pubkey);p.isSigner||(p.isSigner=c.isSigner),p.isWritable||(p.isWritable=c.isWritable)}}return new cn(n,i)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];Ft(t.length<=256,"Max static account keys length exceeded");const n=t.filter(([,p])=>p.isSigner&&p.isWritable),i=t.filter(([,p])=>p.isSigner&&!p.isWritable),s=t.filter(([,p])=>!p.isSigner&&p.isWritable),l=t.filter(([,p])=>!p.isSigner&&!p.isWritable),h={numRequiredSignatures:n.length+i.length,numReadonlySignedAccounts:i.length,numReadonlyUnsignedAccounts:l.length};{Ft(n.length>0,"Expected at least one writable signer key");const[p]=n[0];Ft(p===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const c=[...n.map(([p])=>new X(p)),...i.map(([p])=>new X(p)),...s.map(([p])=>new X(p)),...l.map(([p])=>new X(p))];return[h,c]}extractTableLookup(t){const[n,i]=this.drainKeysFoundInLookupTable(t.state.addresses,h=>!h.isSigner&&!h.isInvoked&&h.isWritable),[s,l]=this.drainKeysFoundInLookupTable(t.state.addresses,h=>!h.isSigner&&!h.isInvoked&&!h.isWritable);if(!(n.length===0&&s.length===0))return[{accountKey:t.key,writableIndexes:n,readonlyIndexes:s},{writable:i,readonly:l}]}drainKeysFoundInLookupTable(t,n){const i=new Array,s=new Array;for(const[l,h]of this.keyMetaMap.entries())if(n(h)){const c=new X(l),p=t.findIndex(w=>w.equals(c));p>=0&&(Ft(p<256,"Max lookup table index exceeded"),i.push(p),s.push(c),this.keyMetaMap.delete(l))}return[i,s]}}class he{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map(n=>new X(n)),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach(n=>this.indexToProgramIds.set(n.programIdIndex,this.accountKeys[n.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:Kt.decode(t.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Qe(this.staticAccountKeys)}static compile(t){const n=cn.compile(t.instructions,t.payerKey),[i,s]=n.getMessageComponents(),h=new Qe(s).compileInstructions(t.instructions).map(c=>({programIdIndex:c.programIdIndex,accounts:c.accountKeyIndexes,data:Kt.encode(c.data)}));return new he({header:i,accountKeys:s,recentBlockhash:t.recentBlockhash,instructions:h})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const n=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){const i=t-n,l=this.accountKeys.length-n-this.header.numReadonlyUnsignedAccounts;return i<l}else{const i=n-this.header.numReadonlySignedAccounts;return t<i}}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((t,n)=>!this.isProgramId(n))}serialize(){const t=this.accountKeys.length;let n=[];Yt(n,t);const i=this.instructions.map(I=>{const{accounts:N,programIdIndex:R}=I,x=Array.from(Kt.decode(I.data));let y=[];Yt(y,N.length);let E=[];return Yt(E,x.length),{programIdIndex:R,keyIndicesCount:ct.Buffer.from(y),keyIndices:N,dataLength:ct.Buffer.from(E),data:x}});let s=[];Yt(s,i.length);let l=ct.Buffer.alloc(_e);ct.Buffer.from(s).copy(l);let h=s.length;i.forEach(I=>{const R=W([yt("programIdIndex"),Rt(I.keyIndicesCount.length,"keyIndicesCount"),zt(yt("keyIndex"),I.keyIndices.length,"keyIndices"),Rt(I.dataLength.length,"dataLength"),zt(yt("userdatum"),I.data.length,"data")]).encode(I,l,h);h+=R}),l=l.slice(0,h);const c=W([Rt(1,"numRequiredSignatures"),Rt(1,"numReadonlySignedAccounts"),Rt(1,"numReadonlyUnsignedAccounts"),Rt(n.length,"keyCount"),zt(lt("key"),t,"keys"),lt("recentBlockhash")]),p={numRequiredSignatures:ct.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:ct.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:ct.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:ct.Buffer.from(n),keys:this.accountKeys.map(I=>Ce(I.toBytes())),recentBlockhash:Kt.decode(this.recentBlockhash)};let w=ct.Buffer.alloc(2048);const m=c.encode(p,w);return l.copy(w,m),w.slice(0,m+l.length)}static from(t){let n=[...t];const i=n.shift();if(i!==(i&Zr))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=n.shift(),l=n.shift(),h=Zt(n);let c=[];for(let N=0;N<h;N++){const R=n.slice(0,ie);n=n.slice(ie),c.push(new X(ct.Buffer.from(R)))}const p=n.slice(0,ie);n=n.slice(ie);const w=Zt(n);let m=[];for(let N=0;N<w;N++){const R=n.shift(),x=Zt(n),y=n.slice(0,x);n=n.slice(x);const E=Zt(n),A=n.slice(0,E),K=Kt.encode(ct.Buffer.from(A));n=n.slice(E),m.push({programIdIndex:R,accounts:y,data:K})}const I={header:{numRequiredSignatures:i,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:l},recentBlockhash:Kt.encode(ct.Buffer.from(p)),accountKeys:c,instructions:m};return new he(I)}}class tn{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const n of this.addressTableLookups)t+=n.readonlyIndexes.length+n.writableIndexes.length;return t}getAccountKeys(t){let n;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");n=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)n=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Qe(this.staticAccountKeys,n)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const n=this.header.numRequiredSignatures,i=this.staticAccountKeys.length;if(t>=i){const s=t-i,l=this.addressTableLookups.reduce((h,c)=>h+c.writableIndexes.length,0);return s<l}else if(t>=this.header.numRequiredSignatures){const s=t-n,h=i-n-this.header.numReadonlyUnsignedAccounts;return s<h}else{const s=n-this.header.numReadonlySignedAccounts;return t<s}}resolveAddressTableLookups(t){const n={writable:[],readonly:[]};for(const i of this.addressTableLookups){const s=t.find(l=>l.key.equals(i.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${i.accountKey.toBase58()}`);for(const l of i.writableIndexes)if(l<s.state.addresses.length)n.writable.push(s.state.addresses[l]);else throw new Error(`Failed to find address for index ${l} in address lookup table ${i.accountKey.toBase58()}`);for(const l of i.readonlyIndexes)if(l<s.state.addresses.length)n.readonly.push(s.state.addresses[l]);else throw new Error(`Failed to find address for index ${l} in address lookup table ${i.accountKey.toBase58()}`)}return n}static compile(t){const n=cn.compile(t.instructions,t.payerKey),i=new Array,s={writable:new Array,readonly:new Array},l=t.addressLookupTableAccounts||[];for(const m of l){const I=n.extractTableLookup(m);if(I!==void 0){const[N,{writable:R,readonly:x}]=I;i.push(N),s.writable.push(...R),s.readonly.push(...x)}}const[h,c]=n.getMessageComponents(),w=new Qe(c,s).compileInstructions(t.instructions);return new tn({header:h,staticAccountKeys:c,recentBlockhash:t.recentBlockhash,compiledInstructions:w,addressTableLookups:i})}serialize(){const t=Array();Yt(t,this.staticAccountKeys.length);const n=this.serializeInstructions(),i=Array();Yt(i,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),l=Array();Yt(l,this.addressTableLookups.length);const h=W([yt("prefix"),W([yt("numRequiredSignatures"),yt("numReadonlySignedAccounts"),yt("numReadonlyUnsignedAccounts")],"header"),Rt(t.length,"staticAccountKeysLength"),zt(lt(),this.staticAccountKeys.length,"staticAccountKeys"),lt("recentBlockhash"),Rt(i.length,"instructionsLength"),Rt(n.length,"serializedInstructions"),Rt(l.length,"addressTableLookupsLength"),Rt(s.length,"serializedAddressTableLookups")]),c=new Uint8Array(_e),p=128,w=h.encode({prefix:p,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map(m=>m.toBytes()),recentBlockhash:Kt.decode(this.recentBlockhash),instructionsLength:new Uint8Array(i),serializedInstructions:n,addressTableLookupsLength:new Uint8Array(l),serializedAddressTableLookups:s},c);return c.slice(0,w)}serializeInstructions(){let t=0;const n=new Uint8Array(_e);for(const i of this.compiledInstructions){const s=Array();Yt(s,i.accountKeyIndexes.length);const l=Array();Yt(l,i.data.length);const h=W([yt("programIdIndex"),Rt(s.length,"encodedAccountKeyIndexesLength"),zt(yt(),i.accountKeyIndexes.length,"accountKeyIndexes"),Rt(l.length,"encodedDataLength"),Rt(i.data.length,"data")]);t+=h.encode({programIdIndex:i.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:i.accountKeyIndexes,encodedDataLength:new Uint8Array(l),data:i.data},n,t)}return n.slice(0,t)}serializeAddressTableLookups(){let t=0;const n=new Uint8Array(_e);for(const i of this.addressTableLookups){const s=Array();Yt(s,i.writableIndexes.length);const l=Array();Yt(l,i.readonlyIndexes.length);const h=W([lt("accountKey"),Rt(s.length,"encodedWritableIndexesLength"),zt(yt(),i.writableIndexes.length,"writableIndexes"),Rt(l.length,"encodedReadonlyIndexesLength"),zt(yt(),i.readonlyIndexes.length,"readonlyIndexes")]);t+=h.encode({accountKey:i.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:i.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(l),readonlyIndexes:i.readonlyIndexes},n,t)}return n.slice(0,t)}static deserialize(t){let n=[...t];const i=n.shift(),s=i&Zr;Ft(i!==s,"Expected versioned message but received legacy message");const l=s;Ft(l===0,`Expected versioned message with version 0 but found version ${l}`);const h={numRequiredSignatures:n.shift(),numReadonlySignedAccounts:n.shift(),numReadonlyUnsignedAccounts:n.shift()},c=[],p=Zt(n);for(let x=0;x<p;x++)c.push(new X(n.splice(0,ie)));const w=Kt.encode(n.splice(0,ie)),m=Zt(n),I=[];for(let x=0;x<m;x++){const y=n.shift(),E=Zt(n),A=n.splice(0,E),K=Zt(n),G=new Uint8Array(n.splice(0,K));I.push({programIdIndex:y,accountKeyIndexes:A,data:G})}const N=Zt(n),R=[];for(let x=0;x<N;x++){const y=new X(n.splice(0,ie)),E=Zt(n),A=n.splice(0,E),K=Zt(n),G=n.splice(0,K);R.push({accountKey:y,writableIndexes:A,readonlyIndexes:G})}return new tn({header:h,staticAccountKeys:c,recentBlockhash:w,compiledInstructions:I,addressTableLookups:R})}}let ue=function(a){return a[a.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",a[a.PROCESSED=1]="PROCESSED",a[a.TIMED_OUT=2]="TIMED_OUT",a[a.NONCE_INVALID=3]="NONCE_INVALID",a}({});const Eo=ct.Buffer.alloc(xn).fill(0);class sr{constructor(t){this.keys=void 0,this.programId=void 0,this.data=ct.Buffer.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map(({pubkey:t,isSigner:n,isWritable:i})=>({pubkey:t.toJSON(),isSigner:n,isWritable:i})),programId:this.programId.toJSON(),data:[...this.data]}}}class le{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:n,nonceInfo:i}=t;this.minNonceContextSlot=n,this.nonceInfo=i}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:n,lastValidBlockHeight:i}=t;this.recentBlockhash=n,this.lastValidBlockHeight=i}else{const{recentBlockhash:n,nonceInfo:i}=t;i&&(this.nonceInfo=i),this.recentBlockhash=n}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(t=>t.toJSON()),signers:this.signatures.map(({publicKey:t})=>t.toJSON())}}add(...t){if(t.length===0)throw new Error("No instructions");return t.forEach(n=>{"instructions"in n?this.instructions=this.instructions.concat(n.instructions):"data"in n&&"programId"in n&&"keys"in n?this.instructions.push(n):this.instructions.push(new sr(n))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,n;if(this.nonceInfo?(t=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?n=[this.nonceInfo.nonceInstruction,...this.instructions]:n=this.instructions):(t=this.recentBlockhash,n=this.instructions),!t)throw new Error("Transaction recentBlockhash required");n.length<1&&console.warn("No instructions provided");let i;if(this.feePayer)i=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)i=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let y=0;y<n.length;y++)if(n[y].programId===void 0)throw new Error(`Transaction instruction index ${y} has undefined program id`);const s=[],l=[];n.forEach(y=>{y.keys.forEach(A=>{l.push({...A})});const E=y.programId.toString();s.includes(E)||s.push(E)}),s.forEach(y=>{l.push({pubkey:new X(y),isSigner:!1,isWritable:!1})});const h=[];l.forEach(y=>{const E=y.pubkey.toString(),A=h.findIndex(K=>K.pubkey.toString()===E);A>-1?(h[A].isWritable=h[A].isWritable||y.isWritable,h[A].isSigner=h[A].isSigner||y.isSigner):h.push(y)}),h.sort(function(y,E){if(y.isSigner!==E.isSigner)return y.isSigner?-1:1;if(y.isWritable!==E.isWritable)return y.isWritable?-1:1;const A={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return y.pubkey.toBase58().localeCompare(E.pubkey.toBase58(),"en",A)});const c=h.findIndex(y=>y.pubkey.equals(i));if(c>-1){const[y]=h.splice(c,1);y.isSigner=!0,y.isWritable=!0,h.unshift(y)}else h.unshift({pubkey:i,isSigner:!0,isWritable:!0});for(const y of this.signatures){const E=h.findIndex(A=>A.pubkey.equals(y.publicKey));if(E>-1)h[E].isSigner||(h[E].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${y.publicKey.toString()}`)}let p=0,w=0,m=0;const I=[],N=[];h.forEach(({pubkey:y,isSigner:E,isWritable:A})=>{E?(I.push(y.toString()),p+=1,A||(w+=1)):(N.push(y.toString()),A||(m+=1))});const R=I.concat(N),x=n.map(y=>{const{data:E,programId:A}=y;return{programIdIndex:R.indexOf(A.toString()),accounts:y.keys.map(K=>R.indexOf(K.pubkey.toString())),data:Kt.encode(E)}});return x.forEach(y=>{Ft(y.programIdIndex>=0),y.accounts.forEach(E=>Ft(E>=0))}),new he({header:{numRequiredSignatures:p,numReadonlySignedAccounts:w,numReadonlyUnsignedAccounts:m},accountKeys:R,recentBlockhash:t,instructions:x})}_compile(){const t=this.compileMessage(),n=t.accountKeys.slice(0,t.header.numRequiredSignatures);return this.signatures.length===n.length&&this.signatures.every((s,l)=>n[l].equals(s.publicKey))||(this.signatures=n.map(i=>({signature:null,publicKey:i}))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(...t){if(t.length===0)throw new Error("No signers");const n=new Set;this.signatures=t.filter(i=>{const s=i.toString();return n.has(s)?!1:(n.add(s),!0)}).map(i=>({signature:null,publicKey:i}))}sign(...t){if(t.length===0)throw new Error("No signers");const n=new Set,i=[];for(const l of t){const h=l.publicKey.toString();n.has(h)||(n.add(h),i.push(l))}this.signatures=i.map(l=>({signature:null,publicKey:l.publicKey}));const s=this._compile();this._partialSign(s,...i)}partialSign(...t){if(t.length===0)throw new Error("No signers");const n=new Set,i=[];for(const l of t){const h=l.publicKey.toString();n.has(h)||(n.add(h),i.push(l))}const s=this._compile();this._partialSign(s,...i)}_partialSign(t,...n){const i=t.serialize();n.forEach(s=>{const l=ho(i,s.secretKey);this._addSignature(s.publicKey,Ce(l))})}addSignature(t,n){this._compile(),this._addSignature(t,n)}_addSignature(t,n){Ft(n.length===64);const i=this.signatures.findIndex(s=>t.equals(s.publicKey));if(i<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[i].signature=ct.Buffer.from(n)}verifySignatures(t){return this._verifySignatures(this.serializeMessage(),t===void 0?!0:t)}_verifySignatures(t,n){for(const{signature:i,publicKey:s}of this.signatures)if(i===null){if(n)return!1}else if(!fo(i,t,s.toBytes()))return!1;return!0}serialize(t){const{requireAllSignatures:n,verifySignatures:i}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),s=this.serializeMessage();if(i&&!this._verifySignatures(s,n))throw new Error("Signature verification failed");return this._serialize(s)}_serialize(t){const{signatures:n}=this,i=[];Yt(i,n.length);const s=i.length+n.length*64+t.length,l=ct.Buffer.alloc(s);return Ft(n.length<256),ct.Buffer.from(i).copy(l,0),n.forEach(({signature:h},c)=>{h!==null&&(Ft(h.length===64,"signature has invalid length"),ct.Buffer.from(h).copy(l,i.length+c*64))}),t.copy(l,i.length+n.length*64),Ft(l.length<=_e,`Transaction too large: ${l.length} > ${_e}`),l}get keys(){return Ft(this.instructions.length===1),this.instructions[0].keys.map(t=>t.pubkey)}get programId(){return Ft(this.instructions.length===1),this.instructions[0].programId}get data(){return Ft(this.instructions.length===1),this.instructions[0].data}static from(t){let n=[...t];const i=Zt(n);let s=[];for(let l=0;l<i;l++){const h=n.slice(0,xn);n=n.slice(xn),s.push(Kt.encode(ct.Buffer.from(h)))}return le.populate(he.from(n),s)}static populate(t,n=[]){const i=new le;return i.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(i.feePayer=t.accountKeys[0]),n.forEach((s,l)=>{const h={signature:s==Kt.encode(Eo)?null:Kt.decode(s),publicKey:t.accountKeys[l]};i.signatures.push(h)}),t.instructions.forEach(s=>{const l=s.accounts.map(h=>{const c=t.accountKeys[h];return{pubkey:c,isSigner:i.signatures.some(p=>p.publicKey.toString()===c.toString())||t.isAccountSigner(h),isWritable:t.isAccountWritable(h)}});i.instructions.push(new sr({keys:l,programId:t.accountKeys[s.programIdIndex],data:Kt.decode(s.data)}))}),i._message=t,i._json=i.toJSON(),i}}const Io=160,xo=64,So=Io/xo,Ao=1e3/So;new X("SysvarC1ock11111111111111111111111111111111");new X("SysvarEpochSchedu1e111111111111111111111111");new X("Sysvar1nstructions1111111111111111111111111");new X("SysvarRecentB1ockHashes11111111111111111111");new X("SysvarRent111111111111111111111111111111111");new X("SysvarRewards111111111111111111111111111111");new X("SysvarS1otHashes111111111111111111111111111");new X("SysvarS1otHistory11111111111111111111111111");new X("SysvarStakeHistory1111111111111111111111111");function Ae(a){return new Promise(t=>setTimeout(t,a))}const ko=Dt("lamportsPerSignature"),Jr=W([V("version"),V("state"),lt("authorizedPubkey"),lt("nonce"),W([ko],"feeCalculator")]);Jr.span;class Mn{constructor(t){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=t.authorizedPubkey,this.nonce=t.nonce,this.feeCalculator=t.feeCalculator}static fromAccountData(t){const n=Jr.decode(Ce(t),0);return new Mn({authorizedPubkey:new X(n.authorizedPubkey),nonce:new X(n.nonce).toString(),feeCalculator:n.feeCalculator})}}const Ro=a=>{const t=a.decode.bind(a),n=a.encode.bind(a);return{decode:t,encode:n}},_o=a=>t=>{const n=Rt(a,t),{encode:i,decode:s}=Ro(n),l=n;return l.decode=(h,c)=>{const p=s(h,c);return gi(ct.Buffer.from(p))},l.encode=(h,c,p)=>{const w=yi(h,a);return i(w,c,p)},l},Le=_o(8);Object.freeze({Create:{index:0,layout:W([V("instruction"),Ht("lamports"),Ht("space"),lt("programId")])},Assign:{index:1,layout:W([V("instruction"),lt("programId")])},Transfer:{index:2,layout:W([V("instruction"),Le("lamports")])},CreateWithSeed:{index:3,layout:W([V("instruction"),lt("base"),ke("seed"),Ht("lamports"),Ht("space"),lt("programId")])},AdvanceNonceAccount:{index:4,layout:W([V("instruction")])},WithdrawNonceAccount:{index:5,layout:W([V("instruction"),Ht("lamports")])},InitializeNonceAccount:{index:6,layout:W([V("instruction"),lt("authorized")])},AuthorizeNonceAccount:{index:7,layout:W([V("instruction"),lt("authorized")])},Allocate:{index:8,layout:W([V("instruction"),Ht("space")])},AllocateWithSeed:{index:9,layout:W([V("instruction"),lt("base"),ke("seed"),Ht("space"),lt("programId")])},AssignWithSeed:{index:10,layout:W([V("instruction"),lt("base"),ke("seed"),lt("programId")])},TransferWithSeed:{index:11,layout:W([V("instruction"),Le("lamports"),ke("seed"),lt("programId")])},UpgradeNonceAccount:{index:12,layout:W([V("instruction")])}});new X("11111111111111111111111111111111");new X("BPFLoader2111111111111111111111111111111111");function To(a){return a&&a.__esModule&&Object.prototype.hasOwnProperty.call(a,"default")?a.default:a}var Uo=Object.prototype.toString,Co=Object.keys||function(a){var t=[];for(var n in a)t.push(n);return t};function ze(a,t){var n,i,s,l,h,c,p;if(a===!0)return"true";if(a===!1)return"false";switch(typeof a){case"object":if(a===null)return null;if(a.toJSON&&typeof a.toJSON=="function")return ze(a.toJSON(),t);if(p=Uo.call(a),p==="[object Array]"){for(s="[",i=a.length-1,n=0;n<i;n++)s+=ze(a[n],!0)+",";return i>-1&&(s+=ze(a[n],!0)),s+"]"}else if(p==="[object Object]"){for(l=Co(a).sort(),i=l.length,s="",n=0;n<i;)h=l[n],c=ze(a[h],!1),c!==void 0&&(s&&(s+=","),s+=JSON.stringify(h)+":"+c),n++;return"{"+s+"}"}else return JSON.stringify(a);case"function":case"undefined":return t?null:void 0;case"string":return JSON.stringify(a);default:return isFinite(a)?a:null}}var Lo=function(a){var t=ze(a,!1);if(t!==void 0)return""+t},cr=To(Lo);const Ke=32;function fn(a){let t=0;for(;a>1;)a/=2,t++;return t}function Fo(a){return a===0?1:(a--,a|=a>>1,a|=a>>2,a|=a>>4,a|=a>>8,a|=a>>16,a|=a>>32,a+1)}class No{constructor(t,n,i,s,l){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=t,this.leaderScheduleSlotOffset=n,this.warmup=i,this.firstNormalEpoch=s,this.firstNormalSlot=l}getEpoch(t){return this.getEpochAndSlotIndex(t)[0]}getEpochAndSlotIndex(t){if(t<this.firstNormalSlot){const n=fn(Fo(t+Ke+1))-fn(Ke)-1,i=this.getSlotsInEpoch(n),s=t-(i-Ke);return[n,s]}else{const n=t-this.firstNormalSlot,i=Math.floor(n/this.slotsPerEpoch),s=this.firstNormalEpoch+i,l=n%this.slotsPerEpoch;return[s,l]}}getFirstSlotInEpoch(t){return t<=this.firstNormalEpoch?(Math.pow(2,t)-1)*Ke:(t-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(t){return this.getFirstSlotInEpoch(t)+this.getSlotsInEpoch(t)-1}getSlotsInEpoch(t){return t<this.firstNormalEpoch?Math.pow(2,t+fn(Ke)):this.slotsPerEpoch}}class ar extends Error{constructor(t,n){super(t),this.logs=void 0,this.logs=n}}class M extends Error{constructor({code:t,message:n,data:i},s){super(s!=null?`${s}: ${n}`:n),this.code=void 0,this.data=void 0,this.code=t,this.data=i,this.name="SolanaJSONRPCError"}}var Po=globalThis.fetch;class Oo extends bi{constructor(t,n,i){const s=l=>{const h=Bi(l,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...n});return"socket"in h?this.underlyingSocket=h.socket:this.underlyingSocket=h,h};super(s,t,n,i),this.underlyingSocket=void 0}call(...t){var i;const n=(i=this.underlyingSocket)==null?void 0:i.readyState;return n===1?super.call(...t):Promise.reject(new Error("Tried to call a JSON-RPC method `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+n+")"))}notify(...t){var i;const n=(i=this.underlyingSocket)==null?void 0:i.readyState;return n===1?super.notify(...t):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+n+")"))}}function vo(a,t){let n;try{n=a.layout.decode(t)}catch(i){throw new Error("invalid instruction; "+i)}if(n.typeIndex!==a.index)throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${a.index}`);return n}const ur=56;class lr{constructor(t){this.key=void 0,this.state=void 0,this.key=t.key,this.state=t.state}isActive(){const t=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===t}static deserialize(t){const n=vo(qo,t),i=t.length-ur;Ft(i>=0,"lookup table is invalid"),Ft(i%32===0,"lookup table is invalid");const s=i/32,{addresses:l}=W([zt(lt(),s,"addresses")]).decode(t.slice(ur));return{deactivationSlot:n.deactivationSlot,lastExtendedSlot:n.lastExtendedSlot,lastExtendedSlotStartIndex:n.lastExtendedStartIndex,authority:n.authority.length!==0?new X(n.authority[0]):void 0,addresses:l.map(h=>new X(h))}}}const qo={index:1,layout:W([V("typeIndex"),Le("deactivationSlot"),Dt("lastExtendedSlot"),yt("lastExtendedStartIndex"),yt(),zt(lt(),we(yt(),-1),"authority")])},Do=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Ko(a){const t=a.match(Do);if(t==null)throw TypeError(`Failed to validate endpoint URL \`${a}\``);const[n,i,s,l]=t,h=a.startsWith("https:")?"wss:":"ws:",c=s==null?null:parseInt(s.slice(1),10),p=c==null?"":`:${c+1}`;return`${h}//${i}${p}${l}`}const Nt=He(Rn(X),T(),a=>new X(a)),Qr=_n([T(),St("base64")]),Wn=He(Rn(ct.Buffer),Qr,a=>ct.Buffer.from(a[0],"base64")),$o=30*1e3;function zo(a){if(/^https?:/.test(a)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return a}function Bt(a){let t,n;if(typeof a=="string")t=a;else if(a){const{commitment:i,...s}=a;t=i,n=s}return{commitment:t,config:n}}function ti(a){return Wt([k({jsonrpc:St("2.0"),id:T(),result:a}),k({jsonrpc:St("2.0"),id:T(),error:k({code:Ve(),message:T(),data:Y(wi())})})])}const Mo=ti(Ve());function st(a){return He(ti(a),Mo,t=>"error"in t?t:{...t,result:L(t.result,a)})}function _t(a){return st(k({context:k({slot:b()}),value:a}))}function an(a){return k({context:k({slot:b()}),value:a})}function dn(a,t){return a===0?new tn({header:t.header,staticAccountKeys:t.accountKeys.map(n=>new X(n)),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map(n=>({programIdIndex:n.programIdIndex,accountKeyIndexes:n.accounts,data:Kt.decode(n.data)})),addressTableLookups:t.addressTableLookups}):new he(t)}const Wo=k({foundation:b(),foundationTerm:b(),initial:b(),taper:b(),terminal:b()}),Go=st(q(v(k({epoch:b(),effectiveSlot:b(),amount:b(),postBalance:b(),commission:Y(v(b()))})))),Ho=q(k({slot:b(),prioritizationFee:b()})),Vo=k({total:b(),validator:b(),foundation:b(),epoch:b()}),jo=k({epoch:b(),slotIndex:b(),slotsInEpoch:b(),absoluteSlot:b(),blockHeight:Y(b()),transactionCount:Y(b())}),Zo=k({slotsPerEpoch:b(),leaderScheduleSlotOffset:b(),warmup:oe(),firstNormalEpoch:b(),firstNormalSlot:b()}),Yo=mr(T(),q(b())),Ee=v(Wt([k({}),T()])),Xo=k({err:Ee}),Jo=St("receivedSignature"),Qo=k({"solana-core":T(),"feature-set":Y(b())}),hr=_t(k({err:v(Wt([k({}),T()])),logs:v(q(T())),accounts:Y(v(q(v(k({executable:oe(),owner:T(),lamports:b(),data:q(T()),rentEpoch:Y(b())}))))),unitsConsumed:Y(b()),returnData:Y(v(k({programId:T(),data:_n([T(),St("base64")])})))})),ts=_t(k({byIdentity:mr(T(),q(b())),range:k({firstSlot:b(),lastSlot:b()})}));function es(a,t,n,i,s,l){const h=n||Po;let c;l!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let p;return i&&(p=async(m,I)=>{const N=await new Promise((R,x)=>{try{i(m,I,(y,E)=>R([y,E]))}catch(y){x(y)}});return await h(...N)}),new mi(async(m,I)=>{const N={method:"POST",body:m,agent:c,headers:Object.assign({"Content-Type":"application/json"},t||{},nc)};try{let R=5,x,y=500;for(;p?x=await p(a,N):x=await h(a,N),!(x.status!==429||s===!0||(R-=1,R===0));)console.log(`Server responded with ${x.status} ${x.statusText}.  Retrying after ${y}ms delay...`),await Ae(y),y*=2;const E=await x.text();x.ok?I(null,E):I(new Error(`${x.status} ${x.statusText}: ${E}`))}catch(R){R instanceof Error&&I(R)}},{})}function ns(a){return(t,n)=>new Promise((i,s)=>{a.request(t,n,(l,h)=>{if(l){s(l);return}i(h)})})}function rs(a){return t=>new Promise((n,i)=>{t.length===0&&n([]);const s=t.map(l=>a.request(l.methodName,l.args));a.request(s,(l,h)=>{if(l){i(l);return}n(h)})})}const is=st(Wo),os=st(Vo),ss=st(Ho),cs=st(jo),as=st(Zo),us=st(Yo),ls=st(b()),hs=_t(k({total:b(),circulating:b(),nonCirculating:b(),nonCirculatingAccounts:q(Nt)})),Sn=k({amount:T(),uiAmount:v(b()),decimals:b(),uiAmountString:Y(T())}),fs=_t(q(k({address:Nt,amount:T(),uiAmount:v(b()),decimals:b(),uiAmountString:Y(T())}))),ds=_t(q(k({pubkey:Nt,account:k({executable:oe(),owner:Nt,lamports:b(),data:Wn,rentEpoch:b()})}))),An=k({program:T(),parsed:Ve(),space:b()}),ps=_t(q(k({pubkey:Nt,account:k({executable:oe(),owner:Nt,lamports:b(),data:An,rentEpoch:b()})}))),gs=_t(q(k({lamports:b(),address:Nt}))),Ge=k({executable:oe(),owner:Nt,lamports:b(),data:Wn,rentEpoch:b()}),ys=k({pubkey:Nt,account:Ge}),ws=He(Wt([Rn(ct.Buffer),An]),Wt([Qr,An]),a=>Array.isArray(a)?L(a,Wn):a),kn=k({executable:oe(),owner:Nt,lamports:b(),data:ws,rentEpoch:b()}),ms=k({pubkey:Nt,account:kn}),bs=k({state:Wt([St("active"),St("inactive"),St("activating"),St("deactivating")]),active:b(),inactive:b()}),Bs=st(q(k({signature:T(),slot:b(),err:Ee,memo:v(T()),blockTime:Y(v(b()))}))),Es=st(q(k({signature:T(),slot:b(),err:Ee,memo:v(T()),blockTime:Y(v(b()))}))),Is=k({subscription:b(),result:an(Ge)}),xs=k({pubkey:Nt,account:Ge}),Ss=k({subscription:b(),result:an(xs)}),As=k({parent:b(),slot:b(),root:b()}),ks=k({subscription:b(),result:As}),Rs=Wt([k({type:Wt([St("firstShredReceived"),St("completed"),St("optimisticConfirmation"),St("root")]),slot:b(),timestamp:b()}),k({type:St("createdBank"),parent:b(),slot:b(),timestamp:b()}),k({type:St("frozen"),slot:b(),timestamp:b(),stats:k({numTransactionEntries:b(),numSuccessfulTransactions:b(),numFailedTransactions:b(),maxTransactionsPerEntry:b()})}),k({type:St("dead"),slot:b(),timestamp:b(),err:T()})]),_s=k({subscription:b(),result:Rs}),Ts=k({subscription:b(),result:an(Wt([Xo,Jo]))}),Us=k({subscription:b(),result:b()}),Cs=k({pubkey:T(),gossip:v(T()),tpu:v(T()),rpc:v(T()),version:v(T())}),fr=k({votePubkey:T(),nodePubkey:T(),activatedStake:b(),epochVoteAccount:oe(),epochCredits:q(_n([b(),b(),b()])),commission:b(),lastVote:b(),rootSlot:v(b())}),Ls=st(k({current:q(fr),delinquent:q(fr)})),Fs=Wt([St("processed"),St("confirmed"),St("finalized")]),Ns=k({slot:b(),confirmations:v(b()),err:Ee,confirmationStatus:Y(Fs)}),Ps=_t(q(v(Ns))),Os=st(b()),ei=k({accountKey:Nt,writableIndexes:q(b()),readonlyIndexes:q(b())}),Gn=k({signatures:q(T()),message:k({accountKeys:q(T()),header:k({numRequiredSignatures:b(),numReadonlySignedAccounts:b(),numReadonlyUnsignedAccounts:b()}),instructions:q(k({accounts:q(b()),data:T(),programIdIndex:b()})),recentBlockhash:T(),addressTableLookups:Y(q(ei))})}),ni=k({pubkey:Nt,signer:oe(),writable:oe(),source:Y(Wt([St("transaction"),St("lookupTable")]))}),ri=k({accountKeys:q(ni),signatures:q(T())}),ii=k({parsed:Ve(),program:T(),programId:Nt}),oi=k({accounts:q(Nt),data:T(),programId:Nt}),vs=Wt([oi,ii]),qs=Wt([k({parsed:Ve(),program:T(),programId:T()}),k({accounts:q(T()),data:T(),programId:T()})]),si=He(vs,qs,a=>"accounts"in a?L(a,oi):L(a,ii)),ci=k({signatures:q(T()),message:k({accountKeys:q(ni),instructions:q(si),recentBlockhash:T(),addressTableLookups:Y(v(q(ei)))})}),en=k({accountIndex:b(),mint:T(),owner:Y(T()),uiTokenAmount:Sn}),ai=k({writable:q(Nt),readonly:q(Nt)}),un=k({err:Ee,fee:b(),innerInstructions:Y(v(q(k({index:b(),instructions:q(k({accounts:q(b()),data:T(),programIdIndex:b()}))})))),preBalances:q(b()),postBalances:q(b()),logMessages:Y(v(q(T()))),preTokenBalances:Y(v(q(en))),postTokenBalances:Y(v(q(en))),loadedAddresses:Y(ai),computeUnitsConsumed:Y(b())}),Hn=k({err:Ee,fee:b(),innerInstructions:Y(v(q(k({index:b(),instructions:q(si)})))),preBalances:q(b()),postBalances:q(b()),logMessages:Y(v(q(T()))),preTokenBalances:Y(v(q(en))),postTokenBalances:Y(v(q(en))),loadedAddresses:Y(ai),computeUnitsConsumed:Y(b())}),ve=Wt([St(0),St("legacy")]),Ie=k({pubkey:T(),lamports:b(),postBalance:v(b()),rewardType:v(T()),commission:Y(v(b()))}),Ds=st(v(k({blockhash:T(),previousBlockhash:T(),parentSlot:b(),transactions:q(k({transaction:Gn,meta:v(un),version:Y(ve)})),rewards:Y(q(Ie)),blockTime:v(b()),blockHeight:v(b())}))),Ks=st(v(k({blockhash:T(),previousBlockhash:T(),parentSlot:b(),rewards:Y(q(Ie)),blockTime:v(b()),blockHeight:v(b())}))),$s=st(v(k({blockhash:T(),previousBlockhash:T(),parentSlot:b(),transactions:q(k({transaction:ri,meta:v(un),version:Y(ve)})),rewards:Y(q(Ie)),blockTime:v(b()),blockHeight:v(b())}))),zs=st(v(k({blockhash:T(),previousBlockhash:T(),parentSlot:b(),transactions:q(k({transaction:ci,meta:v(Hn),version:Y(ve)})),rewards:Y(q(Ie)),blockTime:v(b()),blockHeight:v(b())}))),Ms=st(v(k({blockhash:T(),previousBlockhash:T(),parentSlot:b(),transactions:q(k({transaction:ri,meta:v(Hn),version:Y(ve)})),rewards:Y(q(Ie)),blockTime:v(b()),blockHeight:v(b())}))),Ws=st(v(k({blockhash:T(),previousBlockhash:T(),parentSlot:b(),rewards:Y(q(Ie)),blockTime:v(b()),blockHeight:v(b())}))),Gs=st(v(k({blockhash:T(),previousBlockhash:T(),parentSlot:b(),transactions:q(k({transaction:Gn,meta:v(un)})),rewards:Y(q(Ie)),blockTime:v(b())}))),dr=st(v(k({blockhash:T(),previousBlockhash:T(),parentSlot:b(),signatures:q(T()),blockTime:v(b())}))),pn=st(v(k({slot:b(),meta:v(un),blockTime:Y(v(b())),transaction:Gn,version:Y(ve)}))),Ze=st(v(k({slot:b(),transaction:ci,meta:v(Hn),blockTime:Y(v(b())),version:Y(ve)}))),Hs=_t(k({blockhash:T(),feeCalculator:k({lamportsPerSignature:b()})})),Vs=_t(k({blockhash:T(),lastValidBlockHeight:b()})),js=_t(oe()),Zs=k({slot:b(),numTransactions:b(),numSlots:b(),samplePeriodSecs:b()}),Ys=st(q(Zs)),Xs=_t(v(k({feeCalculator:k({lamportsPerSignature:b()})}))),Js=st(T()),Qs=st(T()),tc=k({err:Ee,logs:q(T()),signature:T()}),ec=k({result:an(tc),subscription:b()}),nc={"solana-client":"js/0.0.0-development"};class yc{constructor(t,n){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const w={};return async m=>{const{commitment:I,config:N}=Bt(m),R=this._buildArgs([],I,void 0,N),x=cr(R);return w[x]=w[x]??(async()=>{try{const y=await this._rpcRequest("getBlockHeight",R),E=L(y,st(b()));if("error"in E)throw new M(E.error,"failed to get block height information");return E.result}finally{delete w[x]}})(),await w[x]}})();let i,s,l,h,c,p;n&&typeof n=="string"?this._commitment=n:n&&(this._commitment=n.commitment,this._confirmTransactionInitialTimeout=n.confirmTransactionInitialTimeout,i=n.wsEndpoint,s=n.httpHeaders,l=n.fetch,h=n.fetchMiddleware,c=n.disableRetryOnRateLimit,p=n.httpAgent),this._rpcEndpoint=zo(t),this._rpcWsEndpoint=i||Ko(t),this._rpcClient=es(t,s,l,h,c,p),this._rpcRequest=ns(this._rpcClient),this._rpcBatchRequest=rs(this._rpcClient),this._rpcWebSocket=new Oo(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(t,n){const{commitment:i,config:s}=Bt(n),l=this._buildArgs([t.toBase58()],i,void 0,s),h=await this._rpcRequest("getBalance",l),c=L(h,_t(b()));if("error"in c)throw new M(c.error,`failed to get balance for ${t.toBase58()}`);return c.result}async getBalance(t,n){return await this.getBalanceAndContext(t,n).then(i=>i.value).catch(i=>{throw new Error("failed to get balance of account "+t.toBase58()+": "+i)})}async getBlockTime(t){const n=await this._rpcRequest("getBlockTime",[t]),i=L(n,st(v(b())));if("error"in i)throw new M(i.error,`failed to get block time for slot ${t}`);return i.result}async getMinimumLedgerSlot(){const t=await this._rpcRequest("minimumLedgerSlot",[]),n=L(t,st(b()));if("error"in n)throw new M(n.error,"failed to get minimum ledger slot");return n.result}async getFirstAvailableBlock(){const t=await this._rpcRequest("getFirstAvailableBlock",[]),n=L(t,ls);if("error"in n)throw new M(n.error,"failed to get first available block");return n.result}async getSupply(t){let n={};typeof t=="string"?n={commitment:t}:t?n={...t,commitment:t&&t.commitment||this.commitment}:n={commitment:this.commitment};const i=await this._rpcRequest("getSupply",[n]),s=L(i,hs);if("error"in s)throw new M(s.error,"failed to get supply");return s.result}async getTokenSupply(t,n){const i=this._buildArgs([t.toBase58()],n),s=await this._rpcRequest("getTokenSupply",i),l=L(s,_t(Sn));if("error"in l)throw new M(l.error,"failed to get token supply");return l.result}async getTokenAccountBalance(t,n){const i=this._buildArgs([t.toBase58()],n),s=await this._rpcRequest("getTokenAccountBalance",i),l=L(s,_t(Sn));if("error"in l)throw new M(l.error,"failed to get token account balance");return l.result}async getTokenAccountsByOwner(t,n,i){const{commitment:s,config:l}=Bt(i);let h=[t.toBase58()];"mint"in n?h.push({mint:n.mint.toBase58()}):h.push({programId:n.programId.toBase58()});const c=this._buildArgs(h,s,"base64",l),p=await this._rpcRequest("getTokenAccountsByOwner",c),w=L(p,ds);if("error"in w)throw new M(w.error,`failed to get token accounts owned by account ${t.toBase58()}`);return w.result}async getParsedTokenAccountsByOwner(t,n,i){let s=[t.toBase58()];"mint"in n?s.push({mint:n.mint.toBase58()}):s.push({programId:n.programId.toBase58()});const l=this._buildArgs(s,i,"jsonParsed"),h=await this._rpcRequest("getTokenAccountsByOwner",l),c=L(h,ps);if("error"in c)throw new M(c.error,`failed to get token accounts owned by account ${t.toBase58()}`);return c.result}async getLargestAccounts(t){const n={...t,commitment:t&&t.commitment||this.commitment},i=n.filter||n.commitment?[n]:[],s=await this._rpcRequest("getLargestAccounts",i),l=L(s,gs);if("error"in l)throw new M(l.error,"failed to get largest accounts");return l.result}async getTokenLargestAccounts(t,n){const i=this._buildArgs([t.toBase58()],n),s=await this._rpcRequest("getTokenLargestAccounts",i),l=L(s,fs);if("error"in l)throw new M(l.error,"failed to get token largest accounts");return l.result}async getAccountInfoAndContext(t,n){const{commitment:i,config:s}=Bt(n),l=this._buildArgs([t.toBase58()],i,"base64",s),h=await this._rpcRequest("getAccountInfo",l),c=L(h,_t(v(Ge)));if("error"in c)throw new M(c.error,`failed to get info about account ${t.toBase58()}`);return c.result}async getParsedAccountInfo(t,n){const{commitment:i,config:s}=Bt(n),l=this._buildArgs([t.toBase58()],i,"jsonParsed",s),h=await this._rpcRequest("getAccountInfo",l),c=L(h,_t(v(kn)));if("error"in c)throw new M(c.error,`failed to get info about account ${t.toBase58()}`);return c.result}async getAccountInfo(t,n){try{return(await this.getAccountInfoAndContext(t,n)).value}catch(i){throw new Error("failed to get info about account "+t.toBase58()+": "+i)}}async getMultipleParsedAccounts(t,n){const{commitment:i,config:s}=Bt(n),l=t.map(w=>w.toBase58()),h=this._buildArgs([l],i,"jsonParsed",s),c=await this._rpcRequest("getMultipleAccounts",h),p=L(c,_t(q(v(kn))));if("error"in p)throw new M(p.error,`failed to get info for accounts ${l}`);return p.result}async getMultipleAccountsInfoAndContext(t,n){const{commitment:i,config:s}=Bt(n),l=t.map(w=>w.toBase58()),h=this._buildArgs([l],i,"base64",s),c=await this._rpcRequest("getMultipleAccounts",h),p=L(c,_t(q(v(Ge))));if("error"in p)throw new M(p.error,`failed to get info for accounts ${l}`);return p.result}async getMultipleAccountsInfo(t,n){return(await this.getMultipleAccountsInfoAndContext(t,n)).value}async getStakeActivation(t,n,i){const{commitment:s,config:l}=Bt(n),h=this._buildArgs([t.toBase58()],s,void 0,{...l,epoch:i??(l==null?void 0:l.epoch)}),c=await this._rpcRequest("getStakeActivation",h),p=L(c,st(bs));if("error"in p)throw new M(p.error,`failed to get Stake Activation ${t.toBase58()}`);return p.result}async getProgramAccounts(t,n){const{commitment:i,config:s}=Bt(n),{encoding:l,...h}=s||{},c=this._buildArgs([t.toBase58()],i,l||"base64",h),p=await this._rpcRequest("getProgramAccounts",c),w=q(ys),m=h.withContext===!0?L(p,_t(w)):L(p,st(w));if("error"in m)throw new M(m.error,`failed to get accounts owned by program ${t.toBase58()}`);return m.result}async getParsedProgramAccounts(t,n){const{commitment:i,config:s}=Bt(n),l=this._buildArgs([t.toBase58()],i,"jsonParsed",s),h=await this._rpcRequest("getProgramAccounts",l),c=L(h,st(q(ms)));if("error"in c)throw new M(c.error,`failed to get accounts owned by program ${t.toBase58()}`);return c.result}async confirmTransaction(t,n){var l;let i;if(typeof t=="string")i=t;else{const h=t;if((l=h.abortSignal)!=null&&l.aborted)return Promise.reject(h.abortSignal.reason);i=h.signature}let s;try{s=Kt.decode(i)}catch{throw new Error("signature must be base58 encoded: "+i)}return Ft(s.length===64,"signature has invalid length"),typeof t=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:n||this.commitment,signature:i}):"lastValidBlockHeight"in t?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:n||this.commitment,strategy:t}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:n||this.commitment,strategy:t})}getCancellationPromise(t){return new Promise((n,i)=>{t!=null&&(t.aborted?i(t.reason):t.addEventListener("abort",()=>{i(t.reason)}))})}getTransactionConfirmationPromise({commitment:t,signature:n}){let i,s,l=!1;const h=new Promise((p,w)=>{try{i=this.onSignature(n,(I,N)=>{i=void 0;const R={context:N,value:I};p({__type:ue.PROCESSED,response:R})},t);const m=new Promise(I=>{i==null?I():s=this._onSubscriptionStateChange(i,N=>{N==="subscribed"&&I()})});(async()=>{if(await m,l)return;const I=await this.getSignatureStatus(n);if(l||I==null)return;const{context:N,value:R}=I;if(R!=null)if(R!=null&&R.err)w(R.err);else{switch(t){case"confirmed":case"single":case"singleGossip":{if(R.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(R.confirmationStatus==="processed"||R.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}l=!0,p({__type:ue.PROCESSED,response:{context:N,value:R}})}})()}catch(m){w(m)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),i!=null&&(this.removeSignatureListener(i),i=void 0)},confirmationPromise:h}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t,strategy:{abortSignal:n,lastValidBlockHeight:i,signature:s}}){let l=!1;const h=new Promise(I=>{const N=async()=>{try{return await this.getBlockHeight(t)}catch{return-1}};(async()=>{let R=await N();if(!l){for(;R<=i;)if(await Ae(1e3),l||(R=await N(),l))return;I({__type:ue.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:c,confirmationPromise:p}=this.getTransactionConfirmationPromise({commitment:t,signature:s}),w=this.getCancellationPromise(n);let m;try{const I=await Promise.race([w,p,h]);if(I.__type===ue.PROCESSED)m=I.response;else throw new Yr(s)}finally{l=!0,c()}return m}async confirmTransactionUsingDurableNonceStrategy({commitment:t,strategy:{abortSignal:n,minContextSlot:i,nonceAccountPubkey:s,nonceValue:l,signature:h}}){let c=!1;const p=new Promise(R=>{let x=l,y=null;const E=async()=>{try{const{context:A,value:K}=await this.getNonceAndContext(s,{commitment:t,minContextSlot:i});return y=A.slot,K==null?void 0:K.nonce}catch{return x}};(async()=>{if(x=await E(),!c)for(;;){if(l!==x){R({__type:ue.NONCE_INVALID,slotInWhichNonceDidAdvance:y});return}if(await Ae(2e3),c||(x=await E(),c))return}})()}),{abortConfirmation:w,confirmationPromise:m}=this.getTransactionConfirmationPromise({commitment:t,signature:h}),I=this.getCancellationPromise(n);let N;try{const R=await Promise.race([I,m,p]);if(R.__type===ue.PROCESSED)N=R.response;else{let x;for(;;){const y=await this.getSignatureStatus(h);if(y==null)break;if(y.context.slot<(R.slotInWhichNonceDidAdvance??i)){await Ae(400);continue}x=y;break}if(x!=null&&x.value){const y=t||"finalized",{confirmationStatus:E}=x.value;switch(y){case"processed":case"recent":if(E!=="processed"&&E!=="confirmed"&&E!=="finalized")throw new $e(h);break;case"confirmed":case"single":case"singleGossip":if(E!=="confirmed"&&E!=="finalized")throw new $e(h);break;case"finalized":case"max":case"root":if(E!=="finalized")throw new $e(h);break;default:}N={context:x.context,value:{err:x.value.err}}}else throw new $e(h)}}finally{c=!0,w()}return N}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:t,signature:n}){let i;const s=new Promise(p=>{let w=this._confirmTransactionInitialTimeout||6e4;switch(t){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{w=this._confirmTransactionInitialTimeout||3e4;break}}i=setTimeout(()=>p({__type:ue.TIMED_OUT,timeoutMs:w}),w)}),{abortConfirmation:l,confirmationPromise:h}=this.getTransactionConfirmationPromise({commitment:t,signature:n});let c;try{const p=await Promise.race([h,s]);if(p.__type===ue.PROCESSED)c=p.response;else throw new Xr(n,p.timeoutMs/1e3)}finally{clearTimeout(i),l()}return c}async getClusterNodes(){const t=await this._rpcRequest("getClusterNodes",[]),n=L(t,st(q(Cs)));if("error"in n)throw new M(n.error,"failed to get cluster nodes");return n.result}async getVoteAccounts(t){const n=this._buildArgs([],t),i=await this._rpcRequest("getVoteAccounts",n),s=L(i,Ls);if("error"in s)throw new M(s.error,"failed to get vote accounts");return s.result}async getSlot(t){const{commitment:n,config:i}=Bt(t),s=this._buildArgs([],n,void 0,i),l=await this._rpcRequest("getSlot",s),h=L(l,st(b()));if("error"in h)throw new M(h.error,"failed to get slot");return h.result}async getSlotLeader(t){const{commitment:n,config:i}=Bt(t),s=this._buildArgs([],n,void 0,i),l=await this._rpcRequest("getSlotLeader",s),h=L(l,st(T()));if("error"in h)throw new M(h.error,"failed to get slot leader");return h.result}async getSlotLeaders(t,n){const i=[t,n],s=await this._rpcRequest("getSlotLeaders",i),l=L(s,st(q(Nt)));if("error"in l)throw new M(l.error,"failed to get slot leaders");return l.result}async getSignatureStatus(t,n){const{context:i,value:s}=await this.getSignatureStatuses([t],n);Ft(s.length===1);const l=s[0];return{context:i,value:l}}async getSignatureStatuses(t,n){const i=[t];n&&i.push(n);const s=await this._rpcRequest("getSignatureStatuses",i),l=L(s,Ps);if("error"in l)throw new M(l.error,"failed to get signature status");return l.result}async getTransactionCount(t){const{commitment:n,config:i}=Bt(t),s=this._buildArgs([],n,void 0,i),l=await this._rpcRequest("getTransactionCount",s),h=L(l,st(b()));if("error"in h)throw new M(h.error,"failed to get transaction count");return h.result}async getTotalSupply(t){return(await this.getSupply({commitment:t,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(t){const n=this._buildArgs([],t),i=await this._rpcRequest("getInflationGovernor",n),s=L(i,is);if("error"in s)throw new M(s.error,"failed to get inflation");return s.result}async getInflationReward(t,n,i){const{commitment:s,config:l}=Bt(i),h=this._buildArgs([t.map(w=>w.toBase58())],s,void 0,{...l,epoch:n??(l==null?void 0:l.epoch)}),c=await this._rpcRequest("getInflationReward",h),p=L(c,Go);if("error"in p)throw new M(p.error,"failed to get inflation reward");return p.result}async getInflationRate(){const t=await this._rpcRequest("getInflationRate",[]),n=L(t,os);if("error"in n)throw new M(n.error,"failed to get inflation rate");return n.result}async getEpochInfo(t){const{commitment:n,config:i}=Bt(t),s=this._buildArgs([],n,void 0,i),l=await this._rpcRequest("getEpochInfo",s),h=L(l,cs);if("error"in h)throw new M(h.error,"failed to get epoch info");return h.result}async getEpochSchedule(){const t=await this._rpcRequest("getEpochSchedule",[]),n=L(t,as);if("error"in n)throw new M(n.error,"failed to get epoch schedule");const i=n.result;return new No(i.slotsPerEpoch,i.leaderScheduleSlotOffset,i.warmup,i.firstNormalEpoch,i.firstNormalSlot)}async getLeaderSchedule(){const t=await this._rpcRequest("getLeaderSchedule",[]),n=L(t,us);if("error"in n)throw new M(n.error,"failed to get leader schedule");return n.result}async getMinimumBalanceForRentExemption(t,n){const i=this._buildArgs([t],n),s=await this._rpcRequest("getMinimumBalanceForRentExemption",i),l=L(s,Os);return"error"in l?(console.warn("Unable to fetch minimum balance for rent exemption"),0):l.result}async getRecentBlockhashAndContext(t){const n=this._buildArgs([],t),i=await this._rpcRequest("getRecentBlockhash",n),s=L(i,Hs);if("error"in s)throw new M(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(t){const n=await this._rpcRequest("getRecentPerformanceSamples",t?[t]:[]),i=L(n,Ys);if("error"in i)throw new M(i.error,"failed to get recent performance samples");return i.result}async getFeeCalculatorForBlockhash(t,n){const i=this._buildArgs([t],n),s=await this._rpcRequest("getFeeCalculatorForBlockhash",i),l=L(s,Xs);if("error"in l)throw new M(l.error,"failed to get fee calculator");const{context:h,value:c}=l.result;return{context:h,value:c!==null?c.feeCalculator:null}}async getFeeForMessage(t,n){const i=Ce(t.serialize()).toString("base64"),s=this._buildArgs([i],n),l=await this._rpcRequest("getFeeForMessage",s),h=L(l,_t(v(b())));if("error"in h)throw new M(h.error,"failed to get fee for message");if(h.result===null)throw new Error("invalid blockhash");return h.result}async getRecentPrioritizationFees(t){var h;const n=(h=t==null?void 0:t.lockedWritableAccounts)==null?void 0:h.map(c=>c.toBase58()),i=n!=null&&n.length?[n]:[],s=await this._rpcRequest("getRecentPrioritizationFees",i),l=L(s,ss);if("error"in l)throw new M(l.error,"failed to get recent prioritization fees");return l.result}async getRecentBlockhash(t){try{return(await this.getRecentBlockhashAndContext(t)).value}catch(n){throw new Error("failed to get recent blockhash: "+n)}}async getLatestBlockhash(t){try{return(await this.getLatestBlockhashAndContext(t)).value}catch(n){throw new Error("failed to get recent blockhash: "+n)}}async getLatestBlockhashAndContext(t){const{commitment:n,config:i}=Bt(t),s=this._buildArgs([],n,void 0,i),l=await this._rpcRequest("getLatestBlockhash",s),h=L(l,Vs);if("error"in h)throw new M(h.error,"failed to get latest blockhash");return h.result}async isBlockhashValid(t,n){const{commitment:i,config:s}=Bt(n),l=this._buildArgs([t],i,void 0,s),h=await this._rpcRequest("isBlockhashValid",l),c=L(h,js);if("error"in c)throw new M(c.error,"failed to determine if the blockhash `"+t+"`is valid");return c.result}async getVersion(){const t=await this._rpcRequest("getVersion",[]),n=L(t,st(Qo));if("error"in n)throw new M(n.error,"failed to get version");return n.result}async getGenesisHash(){const t=await this._rpcRequest("getGenesisHash",[]),n=L(t,st(T()));if("error"in n)throw new M(n.error,"failed to get genesis hash");return n.result}async getBlock(t,n){const{commitment:i,config:s}=Bt(n),l=this._buildArgsAtLeastConfirmed([t],i,void 0,s),h=await this._rpcRequest("getBlock",l);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const c=L(h,$s);if("error"in c)throw c.error;return c.result}case"none":{const c=L(h,Ks);if("error"in c)throw c.error;return c.result}default:{const c=L(h,Ds);if("error"in c)throw c.error;const{result:p}=c;return p?{...p,transactions:p.transactions.map(({transaction:w,meta:m,version:I})=>({meta:m,transaction:{...w,message:dn(I,w.message)},version:I}))}:null}}}catch(c){throw new M(c,"failed to get confirmed block")}}async getParsedBlock(t,n){const{commitment:i,config:s}=Bt(n),l=this._buildArgsAtLeastConfirmed([t],i,"jsonParsed",s),h=await this._rpcRequest("getBlock",l);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const c=L(h,Ms);if("error"in c)throw c.error;return c.result}case"none":{const c=L(h,Ws);if("error"in c)throw c.error;return c.result}default:{const c=L(h,zs);if("error"in c)throw c.error;return c.result}}}catch(c){throw new M(c,"failed to get block")}}async getBlockProduction(t){let n,i;if(typeof t=="string")i=t;else if(t){const{commitment:c,...p}=t;i=c,n=p}const s=this._buildArgs([],i,"base64",n),l=await this._rpcRequest("getBlockProduction",s),h=L(l,ts);if("error"in h)throw new M(h.error,"failed to get block production information");return h.result}async getTransaction(t,n){const{commitment:i,config:s}=Bt(n),l=this._buildArgsAtLeastConfirmed([t],i,void 0,s),h=await this._rpcRequest("getTransaction",l),c=L(h,pn);if("error"in c)throw new M(c.error,"failed to get transaction");const p=c.result;return p&&{...p,transaction:{...p.transaction,message:dn(p.version,p.transaction.message)}}}async getParsedTransaction(t,n){const{commitment:i,config:s}=Bt(n),l=this._buildArgsAtLeastConfirmed([t],i,"jsonParsed",s),h=await this._rpcRequest("getTransaction",l),c=L(h,Ze);if("error"in c)throw new M(c.error,"failed to get transaction");return c.result}async getParsedTransactions(t,n){const{commitment:i,config:s}=Bt(n),l=t.map(p=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([p],i,"jsonParsed",s)}));return(await this._rpcBatchRequest(l)).map(p=>{const w=L(p,Ze);if("error"in w)throw new M(w.error,"failed to get transactions");return w.result})}async getTransactions(t,n){const{commitment:i,config:s}=Bt(n),l=t.map(p=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([p],i,void 0,s)}));return(await this._rpcBatchRequest(l)).map(p=>{const w=L(p,pn);if("error"in w)throw new M(w.error,"failed to get transactions");const m=w.result;return m&&{...m,transaction:{...m.transaction,message:dn(m.version,m.transaction.message)}}})}async getConfirmedBlock(t,n){const i=this._buildArgsAtLeastConfirmed([t],n),s=await this._rpcRequest("getConfirmedBlock",i),l=L(s,Gs);if("error"in l)throw new M(l.error,"failed to get confirmed block");const h=l.result;if(!h)throw new Error("Confirmed block "+t+" not found");const c={...h,transactions:h.transactions.map(({transaction:p,meta:w})=>{const m=new he(p.message);return{meta:w,transaction:{...p,message:m}}})};return{...c,transactions:c.transactions.map(({transaction:p,meta:w})=>({meta:w,transaction:le.populate(p.message,p.signatures)}))}}async getBlocks(t,n,i){const s=this._buildArgsAtLeastConfirmed(n!==void 0?[t,n]:[t],i),l=await this._rpcRequest("getBlocks",s),h=L(l,st(q(b())));if("error"in h)throw new M(h.error,"failed to get blocks");return h.result}async getBlockSignatures(t,n){const i=this._buildArgsAtLeastConfirmed([t],n,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",i),l=L(s,dr);if("error"in l)throw new M(l.error,"failed to get block");const h=l.result;if(!h)throw new Error("Block "+t+" not found");return h}async getConfirmedBlockSignatures(t,n){const i=this._buildArgsAtLeastConfirmed([t],n,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",i),l=L(s,dr);if("error"in l)throw new M(l.error,"failed to get confirmed block");const h=l.result;if(!h)throw new Error("Confirmed block "+t+" not found");return h}async getConfirmedTransaction(t,n){const i=this._buildArgsAtLeastConfirmed([t],n),s=await this._rpcRequest("getConfirmedTransaction",i),l=L(s,pn);if("error"in l)throw new M(l.error,"failed to get transaction");const h=l.result;if(!h)return h;const c=new he(h.transaction.message),p=h.transaction.signatures;return{...h,transaction:le.populate(c,p)}}async getParsedConfirmedTransaction(t,n){const i=this._buildArgsAtLeastConfirmed([t],n,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",i),l=L(s,Ze);if("error"in l)throw new M(l.error,"failed to get confirmed transaction");return l.result}async getParsedConfirmedTransactions(t,n){const i=t.map(h=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([h],n,"jsonParsed")}));return(await this._rpcBatchRequest(i)).map(h=>{const c=L(h,Ze);if("error"in c)throw new M(c.error,"failed to get confirmed transactions");return c.result})}async getConfirmedSignaturesForAddress(t,n,i){let s={},l=await this.getFirstAvailableBlock();for(;!("until"in s)&&(n--,!(n<=0||n<l));)try{const p=await this.getConfirmedBlockSignatures(n,"finalized");p.signatures.length>0&&(s.until=p.signatures[p.signatures.length-1].toString())}catch(p){if(p instanceof Error&&p.message.includes("skipped"))continue;throw p}let h=await this.getSlot("finalized");for(;!("before"in s)&&(i++,!(i>h));)try{const p=await this.getConfirmedBlockSignatures(i);p.signatures.length>0&&(s.before=p.signatures[p.signatures.length-1].toString())}catch(p){if(p instanceof Error&&p.message.includes("skipped"))continue;throw p}return(await this.getConfirmedSignaturesForAddress2(t,s)).map(p=>p.signature)}async getConfirmedSignaturesForAddress2(t,n,i){const s=this._buildArgsAtLeastConfirmed([t.toBase58()],i,void 0,n),l=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),h=L(l,Bs);if("error"in h)throw new M(h.error,"failed to get confirmed signatures for address");return h.result}async getSignaturesForAddress(t,n,i){const s=this._buildArgsAtLeastConfirmed([t.toBase58()],i,void 0,n),l=await this._rpcRequest("getSignaturesForAddress",s),h=L(l,Es);if("error"in h)throw new M(h.error,"failed to get signatures for address");return h.result}async getAddressLookupTable(t,n){const{context:i,value:s}=await this.getAccountInfoAndContext(t,n);let l=null;return s!==null&&(l=new lr({key:t,state:lr.deserialize(s.data)})),{context:i,value:l}}async getNonceAndContext(t,n){const{context:i,value:s}=await this.getAccountInfoAndContext(t,n);let l=null;return s!==null&&(l=Mn.fromAccountData(s.data)),{context:i,value:l}}async getNonce(t,n){return await this.getNonceAndContext(t,n).then(i=>i.value).catch(i=>{throw new Error("failed to get nonce for account "+t.toBase58()+": "+i)})}async requestAirdrop(t,n){const i=await this._rpcRequest("requestAirdrop",[t.toBase58(),n]),s=L(i,Js);if("error"in s)throw new M(s.error,`airdrop to ${t.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(t){if(!t){for(;this._pollingBlockhash;)await Ae(100);const i=Date.now()-this._blockhashInfo.lastFetch>=$o;if(this._blockhashInfo.latestBlockhash!==null&&!i)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const t=Date.now(),n=this._blockhashInfo.latestBlockhash,i=n?n.blockhash:null;for(let s=0;s<50;s++){const l=await this.getLatestBlockhash("finalized");if(i!==l.blockhash)return this._blockhashInfo={latestBlockhash:l,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},l;await Ae(Ao/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-t}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(t){const{commitment:n,config:i}=Bt(t),s=this._buildArgs([],n,"base64",i),l=await this._rpcRequest("getStakeMinimumDelegation",s),h=L(l,_t(b()));if("error"in h)throw new M(h.error,"failed to get stake minimum delegation");return h.result}async simulateTransaction(t,n,i){if("message"in t){const y=t.serialize(),E=ct.Buffer.from(y).toString("base64");if(Array.isArray(n)||i!==void 0)throw new Error("Invalid arguments");const A=n||{};A.encoding="base64","commitment"in A||(A.commitment=this.commitment);const K=[E,A],G=await this._rpcRequest("simulateTransaction",K),it=L(G,hr);if("error"in it)throw new Error("failed to simulate transaction: "+it.error.message);return it.result}let s;if(t instanceof le){let x=t;s=new le,s.feePayer=x.feePayer,s.instructions=t.instructions,s.nonceInfo=x.nonceInfo,s.signatures=x.signatures}else s=le.populate(t),s._message=s._json=void 0;if(n!==void 0&&!Array.isArray(n))throw new Error("Invalid arguments");const l=n;if(s.nonceInfo&&l)s.sign(...l);else{let x=this._disableBlockhashCaching;for(;;){const y=await this._blockhashWithExpiryBlockHeight(x);if(s.lastValidBlockHeight=y.lastValidBlockHeight,s.recentBlockhash=y.blockhash,!l)break;if(s.sign(...l),!s.signature)throw new Error("!signature");const E=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(E)&&!this._blockhashInfo.transactionSignatures.includes(E)){this._blockhashInfo.simulatedSignatures.push(E);break}else x=!0}}const h=s._compile(),c=h.serialize(),w=s._serialize(c).toString("base64"),m={encoding:"base64",commitment:this.commitment};if(i){const x=(Array.isArray(i)?i:h.nonProgramIds()).map(y=>y.toBase58());m.accounts={encoding:"base64",addresses:x}}l&&(m.sigVerify=!0);const I=[w,m],N=await this._rpcRequest("simulateTransaction",I),R=L(N,hr);if("error"in R){let x;if("data"in R.error&&(x=R.error.data.logs,x&&Array.isArray(x))){const y=`
    `,E=y+x.join(y);console.error(R.error.message,E)}throw new ar("failed to simulate transaction: "+R.error.message,x)}return R.result}async sendTransaction(t,n,i){if("version"in t){if(n&&Array.isArray(n))throw new Error("Invalid arguments");const h=t.serialize();return await this.sendRawTransaction(h,n)}if(n===void 0||!Array.isArray(n))throw new Error("Invalid arguments");const s=n;if(t.nonceInfo)t.sign(...s);else{let h=this._disableBlockhashCaching;for(;;){const c=await this._blockhashWithExpiryBlockHeight(h);if(t.lastValidBlockHeight=c.lastValidBlockHeight,t.recentBlockhash=c.blockhash,t.sign(...s),!t.signature)throw new Error("!signature");const p=t.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(p))h=!0;else{this._blockhashInfo.transactionSignatures.push(p);break}}}const l=t.serialize();return await this.sendRawTransaction(l,i)}async sendRawTransaction(t,n){const i=Ce(t).toString("base64");return await this.sendEncodedTransaction(i,n)}async sendEncodedTransaction(t,n){const i={encoding:"base64"},s=n&&n.skipPreflight,l=n&&n.preflightCommitment||this.commitment;n&&n.maxRetries!=null&&(i.maxRetries=n.maxRetries),n&&n.minContextSlot!=null&&(i.minContextSlot=n.minContextSlot),s&&(i.skipPreflight=s),l&&(i.preflightCommitment=l);const h=[t,i],c=await this._rpcRequest("sendTransaction",h),p=L(c,Qs);if("error"in p){let w;throw"data"in p.error&&(w=p.error.data.logs),new ar("failed to send transaction: "+p.error.message,w)}return p.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(t){this._rpcWebSocketConnected=!1,console.error("ws error:",t.message)}_wsOnClose(t){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),t===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([n,i])=>{this._setSubscription(n,{...i,state:"pending"})})}_setSubscription(t,n){var s;const i=(s=this._subscriptionsByHash[t])==null?void 0:s.state;if(this._subscriptionsByHash[t]=n,i!==n.state){const l=this._subscriptionStateChangeCallbacksByHash[t];l&&l.forEach(h=>{try{h(n.state)}catch{}})}}_onSubscriptionStateChange(t,n){var l;const i=this._subscriptionHashByClientSubscriptionId[t];if(i==null)return()=>{};const s=(l=this._subscriptionStateChangeCallbacksByHash)[i]||(l[i]=new Set);return s.add(n),()=>{s.delete(n),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[i]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(i){i instanceof Error&&console.log(`Error when closing socket connection: ${i.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const t=this._rpcWebSocketGeneration,n=()=>t===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async i=>{const s=this._subscriptionsByHash[i];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[i],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:l,method:h}=s;try{this._setSubscription(i,{...s,state:"subscribing"});const c=await this._rpcWebSocket.call(h,l);this._setSubscription(i,{...s,serverSubscriptionId:c,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[c]=s.callbacks,await this._updateSubscriptions()}catch(c){if(c instanceof Error&&console.error(`${h} error for argument`,l,c.message),!n())return;this._setSubscription(i,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:l,unsubscribeMethod:h}=s;if(this._subscriptionsAutoDisposedByRpc.has(l))this._subscriptionsAutoDisposedByRpc.delete(l);else{this._setSubscription(i,{...s,state:"unsubscribing"}),this._setSubscription(i,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(h,[l])}catch(c){if(c instanceof Error&&console.error(`${h} error:`,c.message),!n())return;this._setSubscription(i,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(i,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(t,n){const i=this._subscriptionCallbacksByServerSubscriptionId[t];i!==void 0&&i.forEach(s=>{try{s(...n)}catch(l){console.error(l)}})}_wsOnAccountNotification(t){const{result:n,subscription:i}=L(t,Is);this._handleServerNotification(i,[n.value,n.context])}_makeSubscription(t,n){const i=this._nextClientSubscriptionId++,s=cr([t.method,n],!0),l=this._subscriptionsByHash[s];return l===void 0?this._subscriptionsByHash[s]={...t,args:n,callbacks:new Set([t.callback]),state:"pending"}:l.callbacks.add(t.callback),this._subscriptionHashByClientSubscriptionId[i]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[i]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[i],delete this._subscriptionHashByClientSubscriptionId[i];const h=this._subscriptionsByHash[s];Ft(h!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${i}`),h.callbacks.delete(t.callback),await this._updateSubscriptions()},this._updateSubscriptions(),i}onAccountChange(t,n,i){const s=this._buildArgs([t.toBase58()],i||this._commitment||"finalized","base64");return this._makeSubscription({callback:n,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"account change")}_wsOnProgramAccountNotification(t){const{result:n,subscription:i}=L(t,Ss);this._handleServerNotification(i,[{accountId:n.value.pubkey,accountInfo:n.value.account},n.context])}onProgramAccountChange(t,n,i,s){const l=this._buildArgs([t.toBase58()],i||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:n,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},l)}async removeProgramAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"program account change")}onLogs(t,n,i){const s=this._buildArgs([typeof t=="object"?{mentions:[t.toString()]}:t],i||this._commitment||"finalized");return this._makeSubscription({callback:n,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(t){await this._unsubscribeClientSubscription(t,"logs")}_wsOnLogsNotification(t){const{result:n,subscription:i}=L(t,ec);this._handleServerNotification(i,[n.value,n.context])}_wsOnSlotNotification(t){const{result:n,subscription:i}=L(t,ks);this._handleServerNotification(i,[n])}onSlotChange(t){return this._makeSubscription({callback:t,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(t){await this._unsubscribeClientSubscription(t,"slot change")}_wsOnSlotUpdatesNotification(t){const{result:n,subscription:i}=L(t,_s);this._handleServerNotification(i,[n])}onSlotUpdate(t){return this._makeSubscription({callback:t,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(t){await this._unsubscribeClientSubscription(t,"slot update")}async _unsubscribeClientSubscription(t,n){const i=this._subscriptionDisposeFunctionsByClientSubscriptionId[t];i?await i():console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${n}' events could not be found.`)}_buildArgs(t,n,i,s){const l=n||this._commitment;if(l||i||s){let h={};i&&(h.encoding=i),l&&(h.commitment=l),s&&(h=Object.assign(h,s)),t.push(h)}return t}_buildArgsAtLeastConfirmed(t,n,i,s){const l=n||this._commitment;if(l&&!["confirmed","finalized"].includes(l))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(t,n,i,s)}_wsOnSignatureNotification(t){const{result:n,subscription:i}=L(t,Ts);n.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(i),this._handleServerNotification(i,n.value==="receivedSignature"?[{type:"received"},n.context]:[{type:"status",result:n.value},n.context])}onSignature(t,n,i){const s=this._buildArgs([t],i||this._commitment||"finalized"),l=this._makeSubscription({callback:(h,c)=>{if(h.type==="status"){n(h.result,c);try{this.removeSignatureListener(l)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return l}onSignatureWithOptions(t,n,i){const{commitment:s,...l}={...i,commitment:i&&i.commitment||this._commitment||"finalized"},h=this._buildArgs([t],s,void 0,l),c=this._makeSubscription({callback:(p,w)=>{n(p,w);try{this.removeSignatureListener(c)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},h);return c}async removeSignatureListener(t){await this._unsubscribeClientSubscription(t,"signature result")}_wsOnRootNotification(t){const{result:n,subscription:i}=L(t,Us);this._handleServerNotification(i,[n])}onRootChange(t){return this._makeSubscription({callback:t,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(t){await this._unsubscribeClientSubscription(t,"root change")}}class Xe{constructor(t){this._keypair=void 0,this._keypair=t??rr()}static generate(){return new Xe(rr())}static fromSecretKey(t,n){if(t.byteLength!==64)throw new Error("bad secret key size");const i=t.slice(32,64);if(!n||!n.skipValidation){const s=t.slice(0,32),l=In(s);for(let h=0;h<32;h++)if(i[h]!==l[h])throw new Error("provided secretKey is invalid")}return new Xe({publicKey:i,secretKey:t})}static fromSeed(t){const n=In(t),i=new Uint8Array(64);return i.set(t),i.set(n,32),new Xe({publicKey:n,secretKey:i})}get publicKey(){return new X(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:W([V("instruction"),Le("recentSlot"),yt("bumpSeed")])},FreezeLookupTable:{index:1,layout:W([V("instruction")])},ExtendLookupTable:{index:2,layout:W([V("instruction"),Le(),zt(lt(),we(V(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:W([V("instruction")])},CloseLookupTable:{index:4,layout:W([V("instruction")])}});new X("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:W([yt("instruction"),V("units"),V("additionalFee")])},RequestHeapFrame:{index:1,layout:W([yt("instruction"),V("bytes")])},SetComputeUnitLimit:{index:2,layout:W([yt("instruction"),V("units")])},SetComputeUnitPrice:{index:3,layout:W([yt("instruction"),Le("microLamports")])}});new X("ComputeBudget111111111111111111111111111111");W([yt("numSignatures"),yt("padding"),jt("signatureOffset"),jt("signatureInstructionIndex"),jt("publicKeyOffset"),jt("publicKeyInstructionIndex"),jt("messageDataOffset"),jt("messageDataSize"),jt("messageInstructionIndex")]);new X("Ed25519SigVerify111111111111111111111111111");zn.utils.isValidPrivateKey;zn.getPublicKey;W([yt("numSignatures"),jt("signatureOffset"),yt("signatureInstructionIndex"),jt("ethAddressOffset"),yt("ethAddressInstructionIndex"),jt("messageDataOffset"),jt("messageDataSize"),yt("messageInstructionIndex"),Rt(20,"ethAddress"),Rt(64,"signature"),yt("recoveryId")]);new X("KeccakSecp256k11111111111111111111111111111");var ui;new X("StakeConfig11111111111111111111111111111111");class li{constructor(t,n,i){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=n,this.custodian=i}}ui=li;li.default=new ui(0,0,X.default);Object.freeze({Initialize:{index:0,layout:W([V("instruction"),wo(),mo()])},Authorize:{index:1,layout:W([V("instruction"),lt("newAuthorized"),V("stakeAuthorizationType")])},Delegate:{index:2,layout:W([V("instruction")])},Split:{index:3,layout:W([V("instruction"),Ht("lamports")])},Withdraw:{index:4,layout:W([V("instruction"),Ht("lamports")])},Deactivate:{index:5,layout:W([V("instruction")])},Merge:{index:7,layout:W([V("instruction")])},AuthorizeWithSeed:{index:8,layout:W([V("instruction"),lt("newAuthorized"),V("stakeAuthorizationType"),ke("authoritySeed"),lt("authorityOwner")])}});new X("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:W([V("instruction"),bo()])},Authorize:{index:1,layout:W([V("instruction"),lt("newAuthorized"),V("voteAuthorizationType")])},Withdraw:{index:3,layout:W([V("instruction"),Ht("lamports")])},AuthorizeWithSeed:{index:10,layout:W([V("instruction"),Bo()])}});new X("Vote111111111111111111111111111111111111111");new X("Va1idator1nfo111111111111111111111111111111");k({name:T(),website:Y(T()),details:Y(T()),keybaseUsername:Y(T())});new X("Vote111111111111111111111111111111111111111");W([lt("nodePubkey"),lt("authorizedWithdrawer"),yt("commission"),Dt(),zt(W([Dt("slot"),V("confirmationCount")]),we(V(),-8),"votes"),yt("rootSlotValid"),Dt("rootSlot"),Dt(),zt(W([Dt("epoch"),lt("authorizedVoter")]),we(V(),-8),"authorizedVoters"),W([zt(W([lt("authorizedPubkey"),Dt("epochOfLastAuthorizedSwitch"),Dt("targetEpoch")]),32,"buf"),Dt("idx"),yt("isEmpty")],"priorVoters"),Dt(),zt(W([Dt("epoch"),Dt("credits"),Dt("prevCredits")]),we(V(),-8),"epochCredits"),W([Dt("slot"),Dt("timestamp")],"lastTimestamp")]);const pr={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function wc(a,t){const n=t===!1?"http":"https";if(!a)return pr[n].devnet;const i=pr[n][a];if(!i)throw new Error(`Unknown ${n} cluster: ${a}`);return i}export{yc as C,Xe as K,le as T,wc as c};
